[{"title":"本地无ipv6情况下玩转北邮人和bt","url":"/2024/01/31/本地无ipv6情况下玩转北邮人和bt/","content":"\n# 背景\n\n本人用的是广东广电100M宽带，而广电到2024年了还没有分配IPv6。最近我被拉入玩pt和bt的坑，想要访问北邮人pt并从北邮人下载和上传资源，并且同时想要兼顾科学上网，所以这篇教程就诞生了。\n\n本教程有两种方案，一个是自己购买云服务器使用，一个是使用机场的节点代理。两种方案各有优劣。\n\n# 方案优劣对比\n\n可以根据对比之后选择合适自己的再看对应的教程，或者两种方案都做了，有一些步骤是重复的\n\n## 使用机场节点代理\n\n### 优点\n\n1. 方便快捷\n2. 性价比比较高\n\n### 缺点\n\n1. 不能自由选择配置\n2. 有些机场会把bt流量给封锁了，就算没有封锁，也最好别直接拿来下载bt，除非机场明确说明（一般这种机场会很贵），不然可能会进机场黑名单。不过pt倒不用怕，没有蜜罐，而且机场一般也没有封锁pt流量\n3. 现在的机场一般不会说自己有没有IPv6，有一些有，有一些没有，没有IPv6的无法访问北邮人\n4. 流量一般都是有限的，拿来跑下载上传可能会不够用\n\n## 自己购买云服务器\n\n### 优点\n\n1. 可以相对自由地选择配置\n2. 选择抗[DCMA](https://en.wikipedia.org/wiki/Digital_Millennium_Copyright_Act)的服务器可以随便下载bt，不怕投诉。不过感觉如果不是随便找torrent的话，不专门选抗投诉的服务器应该没啥问题，至少我使用了几天后都没啥问题\n3. 选择不限流量的服务器还可以随便刷流量\n4. 可以选择能跑满家宽的千兆网速服务器\n5. 选了大储存的服务器还能直接在服务器刷pt流量，不用自己本地开机\n\n### 缺点\n\n1. 麻烦\n2. 想要好的服务器，价格可能会贵一些\n\n# 教程\n\n## 使用机场节点代理\n\n### 准备工作\n\n一个代理软件。本文使用的是v2rayn V6.33版本，并且会详解。clash系列的可以参考，应该大差不差\n\n有IPv6的机场\n\n### v2rayn设置\n\n不知道是什么原因，使用系统代理模式的时候，无论我怎么设置，qBittorrent和utorrent都可以与tracker连接但是无法与peers连接。后来我研究tun模式并设置了下，最终能够正常下载pt和bt。所以本文选择的是tun模式\n\n要以管理员身份运行才能开启v2rayn的tun模式，在v2rayn的主页面的下方开启，同时系统代理选择**清除系统代理**\n\n在v2rayn上方点设置->参数设置->开启UDP和流量探测\n\n![image-20240131204506473](https://s1.vika.cn/space/2024/01/31/5634fe53e7164c7684c2c7fcdbf22002)\n\nTun模式设置->启用IPv6\n\n![image-20240131205303448](https://s1.vika.cn/space/2024/01/31/b34d0ab9f67143eeac9a85999a6e1d06)\n\n退到v2rayn主页面，在v2rayn上方点设置->路由设置->启用高级功能。域名解析策略选择AsIs。\n\n![image-20240131210253874](https://s1.vika.cn/space/2024/01/31/62082ec0e8df4c5e9454e63ca8e2594c)\n\n高级功能->添加规则集->别名随便取一个（本文取IPv6）。复制下面这段json配置后到v2rayn页面选择从粘贴板中导入规则。弹出是否追加规则的页面，这里随便选是或者否都可以。\n\n```json\n[\n    {\n      \"port\": \"\",\n      \"outboundTag\": \"proxy\",\n      \"ip\": [],\n      \"domain\": [\n        \"domain:byr.pt\"\n      ],\n      \"process\": [],\n      \"enabled\": true\n    },\n    {\n      \"port\": \"\",\n      \"outboundTag\": \"proxy\",\n      \"ip\": [],\n      \"domain\": [],\n      \"protocol\": [\n        \"bittorrent\"\n      ],\n      \"process\": [],\n      \"enabled\": true\n    },\n    {\n      \"port\": \"\",\n      \"outboundTag\": \"direct\",\n      \"ip\": [\n        \"geoip:private\"\n      ],\n    \"domain\": [],\n    \"process\": [],\n    \"enabled\": true\n    },\n    {\n      \"port\": \"\",\n      \"outboundTag\": \"proxy\",\n      \"ip\": [\n        \"::/128\"\n      ],\n      \"domain\": [],\n      \"process\": [],\n      \"enabled\": true\n    },\n    {\n      \"port\": \"\",\n      \"outboundTag\": \"block\",\n      \"domain\": [\n        \"geosite:category-ads-all\"\n      ],\n      \"enabled\": true\n    },\n    {\n      \"port\": \"\",\n      \"outboundTag\": \"direct\",\n      \"ip\": [],\n      \"domain\": [\n        \"geosite:cn\"\n      ],\n      \"process\": [],\n      \"enabled\": true\n    },\n    {\n      \"port\": \"\",\n      \"outboundTag\": \"direct\",\n      \"ip\": [\n        \"geoip:cn\"\n      ],\n      \"domain\": [],\n      \"process\": [],\n      \"enabled\": true\n    },\n    {\n      \"port\": \"0-65535\",\n      \"outboundTag\": \"proxy\",\n      \"enabled\": true\n    }\n]\n```\n\n![image-20240131211321631](https://s1.vika.cn/space/2024/01/31/78c3ba8bc86d489a92a5c657566085d1)\n\n确定并且选中这个规则集列表后按enter键，之后点确定\n\n![image-20240131220049741](https://s1.vika.cn/space/2024/01/31/8a21e74d0d3048b0bc63dd30b060b396)\n\n回到v2rayn主页面->设置->DNS设置->sing-box DNS设置->点击导入默认DNS配置->把下面的json配置复制后粘贴覆盖到右侧的Tun模式设置->确定\n\n```json\n{\n  \"servers\": [\n    {\n      \"tag\": \"remote\",\n      \"address\": \"tcp://8.8.8.8\",\n      \"detour\": \"proxy\",\n      \"strategy\": \"ipv4_only\"\n    },\n    {\n      \"tag\": \"local\",\n      \"address\": \"223.5.5.5\",\n      \"detour\": \"direct\",\n      \"strategy\": \"ipv4_only\"\n    },\n    {\n      \"tag\": \"block\",\n      \"address\": \"rcode://success\"\n    },\n    {\n      \"tag\": \"ipv6\",\n      \"address\": \"2606:4700:4700::1111\",\n      \"detour\": \"proxy\"\n    }\n  ],\n  \"rules\": [\n    {\n      \"domain_suffix\": [\n        \"byr.pt\"\n      ],\n      \"server\": \"ipv6\",\n      \"disable_cache\": true\n    },\n    {\n      \"geosite\": [\n        \"cn\"\n      ],\n      \"server\": \"local\",\n      \"disable_cache\": true\n    },\n    {\n      \"geosite\": [\n        \"category-ads-all\"\n      ],\n      \"server\": \"block\",\n      \"disable_cache\": true\n    }\n  ],\n  \"strategy\": \"prefer_ipv4\"\n}\n```\n\n![image-20240131220220658](https://s1.vika.cn/space/2024/01/31/6ce3280845604a7ba63a95aa508283df)\n\n### qBittorrent/utorrent设置（可选）\n\n按照北邮人的常见问题里面的配置就行了，qBittorrent的话可以选择绑定singbox_tun网卡（在设置->高级->网络接口选择singbox_tun）。最主要就是要注意客户端有没有开启IPv6。\n\n### 小结\n\n到这里，如果只是想抄作业的话，接下来的原理就不需要看了。用了这套配置，基本上访问大部分的互联网内容都没啥问题（除了一些比较小的站点）。如果访问国内网站有问题，就手动关掉tun模式或者退出v2rayn；如果访问国外网站有问题，就把路由从原来的（本文名为IPv6的那个）改成全局代理就行了。但是如果你想有更高级的用法，或者觉得每次访问有问题的网站时把代理且来切去这样很麻烦，请先去学习理解v2rayn的路由策略、tun模式的工作原理和一些基础的计算机网络知识，然后在我的基础配置上修改。下面是推荐的参考资料。\n\n[节点搭建系列(1)：网络通信的基本过程，访问网站到底发生了什么事情？详细解析DNS原理](https://www.youtube.com/watch?v=_618At72evs)\n\n[【进阶•代理模式篇】看懂就能解决99%的代理问题，详解系统代理、TUN/TAP代理、真VPN代理，clash/v2ray/singbox 虚拟网卡怎么接管系统全局流量？什么是真正的VPN？看完就知道了](https://www.youtube.com/watch?v=qItL005LUik)\n\n[【进阶•DNS代理篇】最完美的DNS解决方案？通过代理DNS请求获取正确的ip，杜绝DNS泄露和DNS污染，解决透明代理下fake-ip存在的问题，开启sniffing流量嗅探亦可解决污染问题](https://www.youtube.com/watch?v=50iVDmqzDW8)\n\n[v2rayn Routing 路由官方文档](https://www.v2fly.org/config/routing.html)\n\n[sing-box官方文档 DNS](https://sing-box.sagernet.org/zh/configuration/dns/)\n\n### 思路\n\n接下来我来讲讲我这么配置的思路，先从相对简单的路由开始。\n\n#### 路由规则\n\n我是在原有的绕过大陆模式下来添加修改的。把domain为`domain:byr.pt`和protocol为`bittorrent`放在最前面经过proxy代理。接着本地ip（如`127.0.0.1`、`::1`等）直连。然后`::/128`指所有过滤了本地IPv6后所有IPv6都经过代理。倒数第二个才放所有的大陆的ip地址。这样就可以在访问国内网站时使用IPv4。\n\n然而如果不配合sing-box的DNS修改的话，实际上是访问不了IPv6的。因为默认DNS的strategy为ipv4_only。如果只是简单地改成prefer_ipv4的话，仍然有不少问题。在访问同时支持IPv4和IPv6的国内的部分网站时，由于IPv4和IPv6的地区不同，所以会出现奇奇怪怪的问题，比如资源加载有问题，严重的话连网页都进不去；在访问同时支持IPv4和IPv6的国外的部分网站时（比如谷歌），不知道是我IPv6的问题还是啥，很容易被识别为异常流量，弹出烦人的谷歌验证。\n\n为了解决这个问题，所以还需要在原有的配置上添加IPv6的dns服务器，其他dns服务器都是IPv4 only。路由设置成除了byr.pt只使用IPv6来做DNS查询，其他都是用IPv4查询DNS访问，这样就没有问题了。\n\n有了上面的思路解释，遇到问题就会根据这个思路来修改我的配置了。\n\n## 自己购买云服务器\n\n### 准备工作 \n\n一台同时有公网IPv4和IPv6的服务器，带宽最好是比自己带宽高的，我这里选1000Mbps够用了，同时每月流量越大越好，无限流量最好。这里我选择了buyvm的拉斯维加斯服务器，个人感觉性价比挺高的。\n\n一个代理软件（可选）。本文使用的是v2rayn，并且会详解。clash系列的可以参考，应该大差不差。\n\n### 服务器设置\n\n使用x-ui面板来配置，十分简单，可以参考下面的教程。有两种方案，一种是选择vmess+ws（需要代理软件），一种是原生socks5（简单，因为没有加密传输，所以理论上相对较快，不需要代理软件，服务器没啥重要信息的话可以选择，安装如图所示设置即可）。\n\n[【零基础】最新保姆级纯小白节点搭建教程，人人都能学会，目前最简单、最安全、最稳定的专属节点搭建方法，手把手自建节点搭建教学，晚高峰高速稳定，4K秒开的科学上网线路体验](https://www.youtube.com/watch?v=SpxTFes1B8U)\n\n![image-20240131233246483](https://s1.vika.cn/space/2024/01/31/0aedcf8bcb924061ba9c31da0d8406fa)\n\n点击左侧的面板设置->xray 相关设置，把过滤掉bittorrent的rules规则清除掉，保存配置后重启面板。\n\n### 选择socks5代理\n\n在qBittorrent设置->连接，按照如图所示设置即可，修改端口、ip、用户名、密码\n\n![image-20240131233938346](https://s1.vika.cn/space/2024/01/31/9e85bfa8e40e4085b9fb70c3a2f59b9e)\n\n然后就行了\n\n### vmess+ws\n\n参考上面那个视频将节点导入到v2rayn。之后的步骤就和[使用机场节点代理的v2rayn设置](###v2rayn设置)一样了。\n","tags":["ipv6 bt pt 北邮人"]},{"title":"Git操作","url":"/2023/07/23/Git操作/","content":"\n将远程仓库更新到本地\n\n```\ngit pull\n```\n\n新建分支\n\n```\ngit branch dev-Aiden\n```\n\n切换分支\n\n```\ngit checkout dev-Aiden\n```\n\n提交修改\n\n```\ngit commit -a -m \"提交信息\"\n```\n\n将修改提交到远程仓库\n\n```\ngit push origin dev-Aiden\n```\n\n删除远程仓库分支\n\n```\ngit push origin --delete dev-Aiden\n```\n\n删除本地分支\n\n```\ngit branch -d dev-Aiden\n```","tags":["开发"]},{"title":"学生白嫖7个月阿里云服务器+后端配置","url":"/2023/07/08/学生白嫖7个月阿里云服务器-后端配置/","content":"\n#  白嫖阿里云服务器\n\n1.进入[高校计划 - 免费学生云服务器 (aliyun.com)](https://developer.aliyun.com/plan/student)，按照提示注册登录领取。在此过程中，还能学习一些阿里云ECS基本操作。\n\n2.在配置服务器时，选择离自己最近的地域，系统我选择Debian  11.7 64位。\n\n# 后端配置\n\n## 换源（阿里云服务器默认换好了阿里的镜像，所以不用换也行）\n\n查看源\n\n```\nsudo nano /etc/apt/sources.list\n```\n\n以`deb`或`deb-src`开头，后跟源的地址。\n\n## 查看已安装软件\n\n```\nsudo apt list --installed\n```\n\n可以看到java后端需要的都没装\n\n## 安装后端需要的东西\n\n### 每次安装新软件前都要确保当前系统是最新的\n\n```\nsudo apt update\n```\n\n### 安装JDK17\n\n```\nsudo apt install openjdk-17-jdk\n```\n\n安装好后可以通过下面命令查看安装情况\n\n```\njava -version\n```\n\n### 安装Maven\n\n```\nsudo apt install maven\n```\n\n查看安装情况\n\n```\nmvn -v\n```\n\n### 安装Tomcat\n\n```\nsudo apt install tomcat9\n```\n\n查看安装情况\n\n1.查看并记住自己电脑的公网ip，可通过这个网站查询www.ip138.com\n\n2.打开阿里云的云服务器ECS管理平台->选择自己那台服务器->安全组->配置规则\n\n![image-20230708153022339](https://s1.vika.cn/space/2023/07/08/e7104a21600b4f92a9fbe77bc763abe6)\n\n3.手动添加->按照图示设置，授权对象是自己的公网ip->保存\n\n![image-20230708153642703](https://s1.vika.cn/space/2023/07/08/e280671b49db4b36a8a756fc684a1d6e)\n\n4.打开浏览器，输入自己的服务器ip地址:8080。（如192.168.1.1:8080，ip地址在实例那里可以看到）\n\n![image-20230708154120236](https://s1.vika.cn/space/2023/07/08/4e14697d7a964138838cd63c06ce75f6)\n\n5.显示这个界面就是成功安装tomcat\n\n![image-20230708154229236](https://s1.vika.cn/space/2023/07/08/4d413f5693ae43fdaf463d0e58d0a1a7)\n\n### 安装MariaDB（替代MySQL）\n\n参考[如何在Debian 11上安装MariaDB - 掘金 (juejin.cn)](https://juejin.cn/post/7162821689133236261)\n\n### 安装Redis\n\n输入下面命令\n\n```\nsudo apt install redis\n```\n\n安装好默认启动Redis服务，可输入下面命令查看情况\n\n```\nsudo systemctl status redis-server\n```\n\n### 安装Docker\n\n```sh\nsudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release\ncurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\necho \\\n  \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/debian \\\n  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io\n```\n\n```sh\ndocker -v\n```\n\n### 安装Docker Compose\n\n```sh\nsudo curl -L \"https://github.com/docker/compose/releases/download/$(curl --silent https://api.github.com/repos/docker/compose/releases/latest | grep '\"tag_name\":' | sed -E 's/.*\"([^\"]+)\".*/\\1/')/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n验证安装成功\n\n```sh\ndocker-compose -v\n```\n\n## 用jar包发送给服务器运行\n\n1.IDEA创建一个空项目，用maven依赖，并在`pom.xml`加上下面的配置。\n\n```xml\n\t<build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.10.1</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-jar-plugin</artifactId>\n                <version>3.2.2</version>\n                <configuration>\n                    <archive>\n                        <manifest>\n                            <mainClass>org.example.Main</mainClass>\n                            <!-- 包含public static void main(String[] args)方法的类的位置 -->\n                        </manifest>\n                    </archive>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n```\n\n2.在IDEA终端运行下面的命令\n\n```\nmvn clean\nmvn package\n```\n\n3.在项目的`target`里面就存放着`.jar`包，把他拖到ECS云助手那里（运维与监控->发送命令/文件（云助手）->发送文件里面）\n\n![image-20230708204043438](https://s1.vika.cn/space/2023/07/08/1ab5a21a3fd040cfb2a927b56fe35166)\n\n4.发送成功后服务器运行下面命令\n\n```\njava -jar 文件名.jar\n```\n\n","tags":["后端"]},{"title":"开发流程","url":"/2023/06/07/开发流程/","content":"\n#  传统瀑布模型\n\n需求->开发->测试->发布->运维\n\n## 优点\n\n1.工作流程直观表达\n\n2.定义了标准的研发阶段\n\n3.以流程为本，理想化模型\n\n## 缺点\n\n流程低效：工作定死，到一定时间做一定的事情，很多时间都是等前面的流程完成\n\n# 敏捷开发\n\n## SAFe框架(The Scaled Agile Framework)\n\nSAFe框架包括一系列的角色、活动、工件和指南，它们共同协调和协作以支持大规模的敏捷开发。\n\n### 目标\n\n是帮助组织在复杂的环境中有效地交付高质量的软件，同时保持敏捷的原则和价值观。\n\n### 关键要素\n\n1. Agile Release Train（ART）：ART是SAFe中的核心组织单位，它是一个跨职能、跨团队的组织，负责按照迭代和发布计划交付价值。ART通常由多个敏捷团队组成，这些团队共同协作开发和交付软件。\n2. PI Planning（Program Increment Planning）：PI Planning是一个全体会议，ART的成员在这个会议上共同规划一个固定时间段（通常为8-12周）的开发工作。在这个会议上，团队制定目标、排列工作项、解决依赖关系，并制定一个可执行的计划。\n3. 精确的迭代：SAFe使用基于时间盒的迭代模型，称为精确的迭代。每个迭代通常持续1-2周，团队在每个迭代中交付可工作的软件增量。\n4. PI演示（PI Demo）：每个PI结束时，ART举行一个PI演示，向利益相关方展示所完成的工作。这有助于实现透明度和共享进展，以便及早获取反馈并进行调整。\n5. Continuous Delivery Pipeline（持续交付流水线）：SAFe提倡建立一条持续交付流水线，以自动化软件交付的过程。这包括开发、集成、测试和部署等环节，以提高交付速度和质量。\n\n### 传统流程\n\n#### 需求阶段\n\n##### MVP（minimum viable product，最小化可行产品）思想\n\n1.站在用户的角度考虑\n\n2.收集用户反馈，快速迭代\n\n##### 四象限法\n\n1. 第一象限：重要且紧急的任务（Important and Urgent）：需要专注于这些任务，并尽快完成它们。\n2. 第二象限：重要但不紧急的任务（Important but Not Urgent）：这个象限通常被认为是最重要的象限，因为它能够帮助你避免被紧急任务所主导。\n3. 第三象限：不重要但紧急的任务（Not Important but Urgent）：需要尽量减少这些任务，或者将它们委派给其他人。\n4. 第四象限：不重要且不紧急的任务（Not Important and Not Urgent）：需要避免过度投入这些任务，以免浪费时间和资源。\n\n#### 开发阶段\n\n##### 云原生\n\n###### 容器化\n\n所有容器共享宿主机的系统，部署的时候，应用和其依赖的操作系统打包成镜像，后端开发不依赖运维创建程序的运行时环境。\n\n###### 微服务框架\n\n各个功能在不同服务中，不同模块需要RPC通信，可以独立扩缩容，每个服务的代码仓库仅由少部分人维护。\n\n###### 云原生IDE\n\n##### Git处理冲突\n\n##### 有代码规范、自测和文档\n\n#### 测试阶段\n\n![img](https://s1.vika.cn/space/2023/06/07/a2343adb0f114605b85b2601f1f6ecb2)\n\n需要进行充分的单元测试\n\n一般至少需要三套环境：\n\n功能环境：开发和测试新开发的功能\n\n集成环境：把不同的功能合并在一起测试\n\n回归环境：验证新的功能对老功能没有影响\n\n#### 发布阶段\n\n没有强大发布系统和服务器资源不足的公司一般使用蛮力发布或者金丝雀发布\n\n有强大发布工具和服务器资源充足的公司一般使用滚动发布和蓝绿发布\n\n#### 运维阶段\n\n有监控日志和报警的平台","tags":["开发"]},{"title":"Go基础语法","url":"/2023/05/28/Go基础语法/","content":"\n#  包、变量和函数\n\n```Go\npackage main\nimport \"fmt\"\nfunc main() {\n\tfmt.Println(\"hello world\")\n}\n```\n\n## 包\n\n每个Go程序都是由包构成。\n\n程序从`main`包开始运行。\n\n### 导入包\n\n#### 分组形式导入包（推荐）\n\n```go\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n```\n\n#### 编写多个导入语句\n\n```go\nimport \"fmt\"\nimport \"math\"\n```\n\n### 导出名\n\n名字以大写字母开头是导出名，如`Println`。未导出的名字在该包外无法访问。\n\n## 函数\n\n类型在变量名之后。\n\n```go\nfunc add(x int, y int) int {\n\treturn x + y\n}\n```\n\n当连续两个或多个函数的已命名形参类型相同时，可以只写最后一个的类型。\n\n```go\nfunc add(x, y int) int {\n\treturn x + y\n}\n```\n\n与上面的例子一样。\n\n### 多值返回\n\n```go\nfunc swap(x, y string) (string, string) {\n\treturn y, x\n}\n```\n\n### 命名返回值\n\n返回值可以被命名，它们被视作定义在函数顶部的变量。\n\n返回值名称应当具有一定意义，它可以作为文档使用。\n\n没有参数的`return`语句返回已命名的返回值，也就是`直接`返回。\n\n直接返回语句应当仅用在下面的短函数中，长函数会影响代码可读性。\n\n```go\nfunc split(sum int) (x, y int) {\n\tx = sum * 4 / 9\n\ty = sum - x\n\treturn\t//等同于return x,y\n}\n```\n\n## 变量\n\n`var`语句用于声明一个变量列表。`var`语句可以出现在包或者函数级别。\n\n```go\nvar c, python, java bool\n\nfunc main() {\n\tvar i int\n\tfmt.Println(i, c, python, java)\n}\n```\n\n```\n0 false false false\n```\n\n### 初始化\n\n变量声明可以包含初始值，每个变量对应一个。\n\n如果初始化值已存在，则可以省略类型；变量会从初始值中获得类型。\n\n```go\nvar i, j int = 1, 2\n\nfunc main() {\n\tvar c, python, java = true, false, \"no!\"\n\tfmt.Println(i, j, c, python, java)\n}\n```\n\n```\n1 2 true false no!\n```\n\n### 短变量声明\n\n在函数中，简介赋值语句`:=`可代替`var`。\n\n在函数外必须以关键字（`var`，`func`等等）开始，不能用`:=`。\n\n```go\nfunc main() {\n\tvar i, j int = 1, 2\n\tk := 3\n\tc, python, java := true, false, \"no!\"\n\tfmt.Println(i, j, k, c, python, java)\n}\n```\n\n### 基本类型\n\n基本类型有\n\n```\nbool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // uint8 的别名\n\nrune // int32 的别名\n    // 表示一个 Unicode 码点\n\nfloat32 float64\n\ncomplex64 complex128\n```\n\n变量声明可以和导入语句一样“分组”成一个语法块。\n\n```go\nvar (\n\tToBe   bool       = false\n\tMaxInt uint64     = 1<<64 - 1\n\tz      complex128 = cmplx.Sqrt(-5 + 12i)\n)\n\nfunc main() {\n\tfmt.Printf(\"Type: %T Value: %v\\n\", ToBe, ToBe)\n\tfmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt)\n\tfmt.Printf(\"Type: %T Value: %v\\n\", z, z)\n}\n```\n\n```\nType: bool Value: false\nType: uint64 Value: 18446744073709551615\nType: complex128 Value: (2+3i)\n```\n\n### 零值\n\n没有明确初始值的变量声明被赋予零值。\n\n数值类型为`0`，布尔类型为`false`，字符串为`\"\"`（空字符串）。\n\n### 类型转换\n\n表达式 `T(v)` 将值 `v` 转换为类型 `T`。Go 在不同类型的项之间赋值时需要必须显式转换。\n\n一些关于数值的转换：\n\n```go\nvar i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n```\n\n或者，更加简单的形式：\n\n```go\ni := 42\nf := float64(i)\nu := uint(f)\n```\n\n### 类型推导\n\n声明变量而不指定其类型时（即不带类型的`:=`或`var = `），变量类型由右值推导得出。\n\n当右值声明了类型时，新变量的类型与其相同：\n\n```go\nvar i int\nj := i //j也是一个int\n```\n\n当右值没有明确类型时，新变量的类型取决于右值常量的精度：\n\n```go\ni := 42           // int\nf := 3.142        // float64\ng := 0.867 + 0.5i // complex128\n```\n\n### 常量\n\n使用`const`关键字。\n\n常量不能用`:=`语法声明。\n\n```go\nconst Pi = 3.14\n```\n\n### 字符串操作\n\n标准库`strings`里面有很多常用的字符串工具函数。比如contains判断一个字符串里面是否有包含另一个字符串，count，index查找某个字符串位置，join连接多个字符串。\n\n### 字符串格式化\n\n可以用标准fmt库里面的相关方法。比如用`Printf`时可以用`%v`来打印任何类型的变量，用`%+v`打印详细结果。\n\n# 流程控制语句：for、if、else、switch和defer\n\n## for\n\n无序小括号\n\n```go\nsum := 0\nfor i := 0; i < 10; i++ {\n    sum += i\n}\nfmt.Println(sum) //45\n```\n\n### for是Go中的“while”\n\n去掉分号的for\n\n```go\nsum := 1\nfor sum < 1000 {\n    sum += sum\n}\nfmt.Println(sum) //1024\n```\n\n### 无限循环\n\n省略循环条件\n\n```go\nfor {\n}\n```\n\n## if\n\n无需小括号\n\n### if简短语句\n\n和`for`一样，if可以在条件表达式前执行一个简单的语句，该语句声明的变量作用域仅在`if`之内。\n\n```go\nfunc pow(x, n, lim float64) float64 {\n\tif v := math.Pow(x, n); v < lim {\n\t\treturn v\n\t}\n\treturn lim\n}\n\nfunc main() {\n\tfmt.Println(\n\t\tpow(3, 2, 10),\n\t\tpow(3, 3, 20),\n\t)\n}\n```\n\n```\n9 20\n```\n\n### if和else\n\n## switch\n\nGo 只运行选定的 case，而非之后所有的 case。Go 自动提供了在这些语言中每个 case 后面所需的 `break` 语句。 除非以 `fallthrough` 语句结束。\n\nGo 的另一点重要的不同在于 switch 的 case 无需为常量，且取值不必为整数。\n\n```go\nfmt.Print(\"Go runs on \")\nswitch os := runtime.GOOS; os {\ncase \"darwin\":\n\tfmt.Println(\"OS X.\")\ncase \"linux\":\n\tfmt.Println(\"Linux.\")\ndefault:\n    // freebsd, openbsd,\n    // plan9, windows...\n    fmt.Printf(\"%s.\\n\", os)\n}\n```\n\n### 无条件的switch\n\n同`switch true`\n\n```go\nt := time.Now()\nswitch {\ncase t.Hour() < 12:\n\tfmt.Println(\"Good morning!\")\ncase t.Hour() < 17:\n\tfmt.Println(\"Good afternoon.\")\ndefault:\n\tfmt.Println(\"Good evening.\")\n}\n```\n\n## defer\n\ndefer 语句会将函数推迟到外层函数返回之后执行。\n\n推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。\n\n```go\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\tfmt.Println(\"hello\")\n}\n```\n\n```\nhello\nworld\n```\n\n### defer栈\n\n推迟的函数调用会被压入一个栈中。当外层函数返回时，被推迟的函数会按照后进先出的顺序调用。\n\n```go\nfunc main() {\n\tfmt.Println(\"counting\")\n\tfor i := 0; i < 10; i++ {\n\t\tdefer fmt.Println(i)\n\t}\n\tfmt.Println(\"done\")\n}\n```\n\n```\ncounting\ndone\n9\n8\n7\n...\n```\n\n# 更多类型：struct、slice和映射\n\n## 指针\n\n类型`*T`是指向`T`类型值的指针。其零值为`nil`。\n\n```go\nvar p *int\n```\n\n`&`操作符会生成一个指向其操作数的指针。\n\n```go  \ni := 42 \np = &i \n```\n\n `*`操作符表示指针指向的底层值。\n\n```go\nfmt.Println(*p) // 通过指针p读取i\n*p = 21 //通过指针p设置i\n```\n\n##  结构体\n\n一个结构体（struct）就是一组字段（field）。\n\n```go\ntype Vertex struct {\n\tX int\n\tY int\n}\n\nfunc main() {\n\tfmt.Println(Vertex{1, 2})\n}\n```\n\n```\n{1 2}\n```\n\n### 结构体字段\n\n结构体字段使用`.`来访问。\n\n```go\nv.X = 4\n```\n\n### 结构体指针\n\n通过`(*p).X`来访问其字段，也可以隐式间接引用`p.X`\n\n```go\nv := Vertex{1, 2}\np := &v\np.X = 1e9\n```\n\n### 结构体用法\n\n结构体通过直接列出字段的值来新分配一个结构体。\n\n使用 `Name:` 语法可以仅列出部分字段。（字段名的顺序无关。）\n\n特殊的前缀 `&` 返回一个指向结构体的指针。\n\n```go\ntype Vertex struct {\n\tX, Y int\n}\nvar (\n\tv1 = Vertex{1, 2}  // 创建一个 Vertex 类型的结构体\n\tv2 = Vertex{X: 1}  // Y:0 被隐式地赋予\n\tv3 = Vertex{}      // X:0 Y:0\n\tp  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）\n)\n```\n\n### JSON处理\n\n对于`struct`类型，可以用`encoding/json`包里面的`json.Marshaler`来序列化或者反序列化。\n\n## 数组\n\n表达式\n\n```go\nvar a [10]int\n```\n\n## 切片\n\n切片为数组提供动态大小的、灵活的视角。在实践中，切片比数组更常用。\n\n形式：`[]T`\n\n切片通过上届和下界来界定：`a[low : high]`，左闭右开\n\n```go\nprimes := [6]int{2, 3, 5, 7, 11, 13}\nvar s []int = primes[1:4]\nfmt.Println(s)\n```\n\n### 切片就像数组的引用\n\n切片不储存任何数据，它只是描述了底层数组中的一段。\n\n更改切片的元素会修改其底层数组中对应的元素。\n\n与它共享底层数组的切片都会观测到这些修改。\n\n### 切片用法\n\n类似于没有长度的数组。\n\n```go\n[]bool{true, true, false}\n```\n\n切片下界的默认值为 `0`，上界则是该切片的长度。\n\n```go\nvar a [10]int \na[0:10] //等价于a[:10]、a[0:]和a[:]\n```\n\n### 切片的长度与容量\n\n假设有切片`s`\n\n长度：它所包含的元素个数。通过`len(s)`获取。\n\n容量：从它的第一个元素开始数，到其底层数组元素末尾的个数。通过`cap(s)`获取。\n\n```go\nfunc main() {\n\ts := []int{2, 3, 5, 7, 11, 13}\n\tprintSlice(s) //len=6 cap=6 [2 3 5 7 11 13]\n\t// 截取切片使其长度为 0\n\ts = s[:0]\n\tprintSlice(s) //len=0 cap=6 []\n\t// 拓展其长度\n\ts = s[:4]\n\tprintSlice(s) //len=4 cap=6 [2 3 5 7]\n\t// 舍弃前两个值\n\ts = s[2:]\n\tprintSlice(s) //len=2 cap=4 [5 7]\n}\n\nfunc printSlice(s []int) {\n\tfmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s)\n}\n```\n\n### nil切片\n\n切片的零值是`nil`，nil切片的长度和容量为0且没有底层数组。\n\n```go\nvar s []int\n```\n\n### 用make创建切片\n\n切片可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：\n\n```go\na := make([]int, 5)  // len(a)=5\n```\n\n要指定它的容量，需向 `make` 传入第三个参数：\n\n```go\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5\nb = b[:cap(b)] // len(b)=5, cap(b)=5\n```\n\n### 切片的切片\n\n```go\nboard := [][]string{\n\t[]string{\"_\", \"_\", \"_\"},\n    []string{\"_\", \"_\", \"_\"},\n    []string{\"_\", \"_\", \"_\"},\n}\n```\n\n### 向切片添加元素\n\n用`append`函数。\n\n原型：\n\n```go\nfunc append(s []T, vs ...T) []T\n```\n\n`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，其余类型为 `T` 的值将会追加到该切片的末尾。\n\n当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。\n\n```go\n\tvar s []int //len=0 cap=0 []\n\t// 添加一个空切片\n\ts = append(s, 0) //len=1 cap=1 [0]\n\t// 这个切片会按需增长\n\ts = append(s, 1) //len=2 cap=2 [0 1]\n\t// 可以一次性添加多个元素\n\ts = append(s, 2, 3, 4) //len=5 cap=6 [0 1 2 3 4]\n```\n\n## range\n\n`for` 循环的 `range` 形式可遍历切片或映射。\n\n当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。\n\n```go\nvar pow = []int{1, 2, 4, 8}\nfor i, v := range pow {\n\tfmt.Printf(\"下标：%d，对应元素：%d\\n\", i, v) //0,1 1,2 2,4 3,8\n}\n```\n\n可以将下标或值赋予 `_` 来忽略它。\n\n```go\nfor i, _ := range pow\nfor _, value := range pow\n```\n\n若只需要索引，忽略第二个变量即可。\n\n```go\nfor i := range pow\n```\n\n## map映射\n\n映射将键映射到值。映射的零值为 `nil` 。`nil` 映射既没有键，也不能添加键。`make` 函数会返回给定类型的映射，并将其初始化备用。\n\n```go\ntype Vertex struct {\n\tLat, Long float64\n}\nvar m map[string]Vertex\nfunc main() {\n\tm = make(map[string]Vertex)\n\tm[\"Bell Labs\"] = Vertex{\n\t\t40.68433, -74.39967,\n\t}\n\tfmt.Println(m[\"Bell Labs\"]) //{40.68433 -74.39967}\n}\n```\n\n```go\ntype Vertex struct {\n\tLat, Long float64\n}\nvar m = map[string]Vertex{\n\t\"Bell Labs\": Vertex{\n\t\t40.68433, -74.39967,\n\t},\n\t\"Google\": Vertex{\n\t\t37.42202, -122.08408,\n\t},\n}\nfunc main() {\n\tfmt.Println(m) //map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]\n\tfmt.Println(m[\"Google\"]) //{37.42202 -122.08408}\n}\n```\n\n若顶级类型只是一个类型名，你可以在文法的元素中省略它。\n\n```go\nvar m = map[string]Vertex{\n\t\"Bell Labs\": {40.68433, -74.39967},\n\t\"Google\":    {37.42202, -122.08408},\n}\n```\n\n### 修改映射\n\n在映射 `m` 中插入或修改元素：\n\n```\nm[key] = elem\n```\n\n获取元素：\n\n```\nelem = m[key]\n```\n\n删除元素：\n\n```\ndelete(m, key)\n```\n\n通过双赋值检测某个键是否存在：\n\n```\nelem, ok = m[key]\n```\n\n若 `key` 在 `m` 中，`ok` 为 `true` ；否则，`ok` 为 `false`。若 `key` 不在映射中或者不存在，那么 `elem` 是该映射元素类型的零值。\n\n**注** ：若 `elem` 或 `ok` 还未声明，可以使用短变量声明：\n\n```\nelem, ok := m[key]\n```\n\n## 函数值\n\n函数也是值。它们可以像其它值一样传递。函数值可以用作函数的参数或返回值。\n\n```go\nfunc compute(fn func(float64, float64) float64) float64 {\n\treturn fn(3, 4)\n}\nfunc main() {\n\thypot := func(x, y float64) float64 {\n\t\treturn math.Sqrt(x*x + y*y)\n\t}\n\tfmt.Println(hypot(5, 12))\n\tfmt.Println(compute(hypot))\n\tfmt.Println(compute(math.Pow))\n}\n```\n\n# 方法和接口\n\n## 方法\n\nGo 没有类。不过你可以为结构体类型定义方法。方法就是一类带特殊的 **接收者** 参数的函数。方法接收者在它自己的参数列表内，位于 `func` 关键字和方法名之间。\n\n```go\nfunc (v Vertex) Abs() float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n...\n\tfmt.Println(v.Abs()) //调用方法\n```\n\n在此例中，`Abs` 方法拥有一个名为 `v`，类型为 `Vertex` 的接收者。\n\n方法只是个带接收者参数的函数。\n\n```go\nfunc Abs(v Vertex) float64 {\n\treturn math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n...\n\tfmt.Println(Abs(v)) //调用函数\n```\n\n在为非结构体类型声明方法时，接收者的类型定义和方法声明必须在同一包内；不能为基本类型声明方法。\n\n```go\ntype MyFloat float64\nfunc (f MyFloat) Abs() float64 { //不能直接func (f float64) Abs() float64 {\n\tif f < 0 {\n\t\treturn float64(-f)\n\t}\n\treturn float64(f)\n}\n```\n\n### 指针接收者\n\n可以为指针接收者声明方法。同样，接受者指针指向的类型不能是基本类型。指针用的更多。\n\n```go\nfunc (v *Vertex) Scale(f float64) {\n```\n\n以指针为接收者的方法被调用时，接收者既能为值又能为指针：\n\n```go\nfunc (v *Vertex) Scale(f float64) {\n...\n}\n...\nvar v Vertex\nv.Scale(5)  // OK\np := &v\np.Scale(10) // OK\n```\n\nGo 会将语句 `v.Scale(5)` 解释为 `(&v).Scale(5)`。\n\n同理，而以值为接收者的方法被调用时，接收者既能为值又能为指针。\n\n## 接口\n\n## 错误\n\n用一个函数来处理错误。错误处理是可以自定义的，\n\n```go\ntype MyError struct {\n\tWhen time.Time\n\tWhat string\n}\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf(\"at %v, %s\",\n\t\te.When, e.What)\n}\nfunc run() error {\n\treturn &MyError{\n\t\ttime.Now(),\n\t\t\"it didn't work\",\n\t}\n}\nfunc main() {\n\tif err := run(); err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n```\n\n# 并发\n\n## goroutine（Go程）\n\ngoroutine是由Go运行时管理的轻量级线程。\n\n","tags":["Go"]},{"title":"Java线程池","url":"/2023/04/23/Java线程池/","content":"\n参考文档：[Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)\n\n# 线程池的好处\n\n1.降低资源消耗\n\n2.提高响应速度\n\n3.提高线程的可管理性：线程无限创建而带来的不合理分布的问题导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。\n\n4.提供更多更强大的功能：线程池有可扩展性，允许开发人员向其中增加更多的功能。\n\n# 线程池解决的问题\n\n解决的核心问题：资源管理问题。\n\n# 线程池核心设计与实现\n\nJava中使用的是ThreadPoolExecutor类\n\n## 总体设计\n\n基于JDK 1.8源码分析。下面是ThradPoolExecutor的UML类图。\n\n![](https://s1.vika.cn/space/2023/04/26/23f4fc76bc2c41e789b31cbc756b42ac)\n\nExecutor接口（顶层）:将任务提交和任务执行进行解耦。用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。\n\nExecutorService接口:（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法。（2）提供管理线程池的方法，如停止线程池的运行。AbstractExecutorService是上层的抽象类，将执行任务的流程串流，保证下层的实现只需要关注一个执行任务的方法。实现类ThreadPoolExecutor实现最复杂的运行部分，一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。\n\nThreadPoolExecutor运行机制：\n\n![](https://s1.vika.cn/space/2023/04/26/40efd922bc9e4a359212f828e2164343)\n\n线程池运行分为两部分：任务管理（生产者）、线程管理（消费者）。\n\n任务管理：任务提交后，线程池会判断该任务后续的流转：1.直接申请线程执行任务2.缓冲到队列中等待线程执行3.拒绝该任务。\n\n线程管理：被统一维护在线程池内，根据任务请求进行线程分配，当线程执行完成后会继续获取新的任务去执行，最终当线程获取不了任务时被回收。\n\n## 生命周期管理\n\n线程池的运行状态是由内部来维护。线程池内用1个变量维护两个值：运行状态(runState)和线程数量(workerCount)。在具体实现中，这两个关键参数的维护放在一起：\n\n~~~java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n~~~\n\nctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段。高3位保存runState，低29位保存workerCount，两变量互不干扰，可避免出现不一致的情况，节省锁资源。\n\n获取生命周期状态、获取线程池线程数量方法：\n\n~~~java\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; } //计算当前运行状态\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }  //计算当前线程数量\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }   //通过状态和线程数生成ctl\n~~~\n\nThreadPoolExecutor的5种运行状态：\n\n![img](https://s1.vika.cn/space/2023/04/27/97c3b7ed420148e58bd0d9b43ff12240)\n\n其生命周期转换如下所示：\n\n![图3 线程池生命周期](https://s1.vika.cn/space/2023/04/27/f1cca7f4da5448b58dd9889998a9bb9a)\n\n## 任务执行机制\n\n### 任务调度\n\n任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务如何执行是由这个阶段决定的。\n\n首先，所有任务调度是由execute方法完成，这部分完成的工作是：检查现在线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程。执行过程如下：\n\n![图4 任务调度流程](https://s1.vika.cn/space/2023/04/27/d6171d2754524b35ba7f56937efef4b0)\n\n其中，线程数为workerCount，核心（线程）数为corePoolSize，最大线程数为maximumPoolSize。\n\n### 任务缓冲\n\n任务缓冲模块是线程池能够管理任务的核心部分。通过阻塞队列实现任务和线程两者的解耦。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。\n\n线程队列(BlockingQueue)是支持两个附加操作的队列：在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，储存元素的线程会等待队列可用。生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。\n\n下面线程1往阻塞队列中添加元素，线程2从阻塞队列中语出元素：\n\n![图5 阻塞队列](https://s1.vika.cn/space/2023/04/29/d88959afc97843448eaf7db149b4dcf0)\n\n下面是阻塞队列的成员：\n\n![img](https://s1.vika.cn/space/2023/04/29/0fbd6ba386664b1bbc5d0d277e3936f6)\n\n### 任务申请\n\n从队列中获取任务的流程(getTask)：\n\n![图6 获取任务流程图](https://s1.vika.cn/space/2023/04/29/16fd943d6f814d36aee30d7d6856b90f)\n\n工作线程Worker会不断接收新任务去执行，而当工作线程Worker接收不到任务的时候，就会开始被回收。\n\n### 任务拒绝\n\n当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时拒绝任务。\n\n拒绝策略是预购接口\n\n~~~java\npublic interface RejectedExecutionHandler {\n    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);\n}\n~~~\n\n用户可以通过实现该接口定制拒绝策略，也可以选择JDK提供的四种已有拒绝策略，其特点如下：\n\n![img](https://s1.vika.cn/space/2023/04/29/18c4b971010b462e971350a32079a55b)\n\n## Worker线程管理\n\n### Worker线程\n\n线程池为了掌握线程的状态并维护线程的生命周期，设计了线程池内的工作线程Worker。\n\n~~~java\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable{\n    final Thread thread;//Worker持有的线程\n    Runnable firstTask;//初始化的任务，可以为null\n}\n~~~\n\nWorker这个工作线程，实现了Runnable接口，并持有一个线程thread，一个初始化的任务firstTask。thread是在调用构造方法时通过ThreadFactory来创建的线程，可以用来执行任务；firstTask用它来保存传入的第一个任务，这个任务可以有也可以为null。如果这个值是非空的，那么线程就会在启动初期立即执行这个任务，也就对应核心线程创建时的情况；如果这个值是null，那么就需要创建一个线程去执行任务列表（workQueue）中的任务，也就是非核心线程的创建。\n\n![图7 Worker执行任务](https://s1.vika.cn/space/2023/04/29/06d766729f124844903012cd6adfa036)\n\n线程池需要管理线程的生命周期，需要在线程长时间不运行的时候进行回收。线程池使用一张Hash表去持有线程的引用，这样可以通过添加引用、移除引用这样的操作来控制线程的生命周期。这个时候重要的就是如何判断线程是否在运行。\n\nWorker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反应线程现在的执行状态。\n\n1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。 2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。\n\n![图8 线程池回收过程](https://s1.vika.cn/space/2023/04/29/814ef7e051bb4e4cacd331448295f104)\n\n### Worker线程增加\n\n通过线程池中addWorker()方法增加。该步骤仅仅完成增加线程，并使它运行，最后返回是否成功这个结果。\n\naddWorker两个参数：firstTask用于指定新增的线程执行的第一个任务，可为空；core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize。\n\n![图9 申请线程执行流程图](https://s1.vika.cn/space/2023/04/29/59e72d334af1457cb534ea32ce74f04d)\n\n### Worker线程回收\n\n线程池中线程的销毁依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程被JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可。Worker被创建出来后，就会不断地进行轮询，然后获取任务去执行，核心线程可以无限等待获取任务，非核心线程要限时获取任务。当Worker无法获取到任务，也就是获取的任务为空时，循环会结束，Worker会主动消除自身在线程池内的引用。\n\n~~~java\ntry {\n  while (task != null || (task = getTask()) != null) {\n    //执行任务\n  }\n} finally {\n  processWorkerExit(w, completedAbruptly);//获取不到任务时，主动回收自己\n}\n~~~\n\n线程回收的工作是在processWorkerExit方法完成的。\n\n![图10 线程销毁流程](https://s1.vika.cn/space/2023/04/29/4a8cec0781f4460799d63310e0472d18)\n\n**Worker线程执行任务**\n\n在Worker类中的run方法调用了runWorker方法来执行任务，runWorker方法的执行过程如下：\n\n1.while循环不断地通过getTask()方法获取任务。 2.getTask()方法从阻塞队列中取任务。 3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态。 4.执行任务。 5.如果getTask结果为null则跳出循环，执行processWorkerExit()方法，销毁线程。\n\n![图11 执行任务流程](https://s1.vika.cn/space/2023/04/29/cec6a5674b12476593003b3a496ac2ad)","tags":["线程池"]},{"title":"口琴曲（长期更新）","url":"/2023/04/22/口琴曲（长期更新）/","content":"\n本文选择我比较喜欢的游戏口琴曲的简谱（只有数字）。\n\n# BB's theme\n\n~~~\n2 1 5 3\n\n2 2 3 4 1\n\n2 1 5 3\n\n3 4 5 6 1\n~~~\n\n# Faster than light\n\n~~~\n6 +2 +1 3\n\n2 +2 +1 4 5\n\n6 #6 6 6\n\n4 +2 +1 5\n\n6 +2 +1 3\n\n2 +2 +1 4 5\n\n6 #6 6 6\n\n6 5 4 4 3\n\n\n\n6 +2 +1 3\n\n2 +2 +1 4 5\n\n6 +4 +3 5\n\n4 +2 +1 5\n~~~\n\n# Metal Gear Solid main theme\n\n~~~\n3 2 1 1 2 3 -6 3 2\n\n1 2 3 6 5 3 1 2\n\n3 6 +1 7 +1 +2 +1 6\n\n5 6 7 +1 7 6 5 6\n\n转成D调了下面\n3 2 1 1 2 3 -6 3 2\n\n1 2 3 6 5 3 1 2\n\n3 6 +1 7 +1 +2 +1 6\n\n5 6 7 +1 7 6 5 6\n\n7 +1 2 3 5 6\n~~~\n\n# Ori and the blind forest main theme\n\n~~~\n+1 7 6 5 3 \n\n+1 7 6 7\n\n+1 7 6 5 3\n\n2 1 2 3\n\n+1 7 6 5 3\n\n+1 7 6 7 +1 +2 +3 +3 +3 +2 +5 +3 +1 +2 +1 7 6\n~~~\n\n# Will the circle be unbroken\n\n~~~\n-7 1 3 3\n\n6 4 3 6\n\n6 4 3_3 3 1 -7\n\n-7 1 3 3\n\n6 7 7 6\n\n3 4 6 6 4 4 3\n~~~\n\n# 灯火之星\n\n~~~\n234 24[1]7675\n\n#665 4565453\n\n234 24[1]767[2]\n\n#665 45654535【12】\n\n\n\n453 234565 453212\n\n453 234565312\n\n2345-6-\n\n453 234565 453212\n\n453 234565312 \n\n2345[1]6\n\n5555- 4#241\n\n6666 4211(#6)\n\n(#66#65)55\n\n2#1 #13 #6655-#4566-\n~~~\n\n# 动森主题曲\n\n~~~\n6 4 +2 +1 6 4 2 5\n\n4 5 6 +1 +3 +4 +1\n~~~\n\n# 货郎\n\n~~~\n4 1 2 3 2 1 -7 -7 2 4\n\n3 2 1 1 3 2 1 1\n\n3 5 7 5 4 6 4 2\n~~~\n\n# 力巴尔主题曲\n\n~~~\n1=C\n\n1 1(#6)(#5)(#6) (#2)\n\n(4) (4)(5)(#5)(#2) 11\n\n(#5)(5)(4) (5)1 4 #2#1#2 \n\n#2#11 (#6)(#5)(4)\n\n4 #2#64 #2 #1#5#2 #1 #1 (7) #4 【#1】【#2】 #6\n\n#6#5【#2】#6 #5#4【#1】#5\n\n#437 【#4】 【#5】【#2】\n\n【1】 【1】#6#5#6 #2\n\n4 45#5#2 11\n\n#554 5【1】 【4】 【#2】【#1】【#2】\n\n【#2】【#1】1 #6#54 4 #24\n~~~\n\n# 米法主题曲\n\n~~~\n3434343 32125343\n\n3434376 65675656\n\n\n\n3212536 65675656\n\n3434376 65675656\n~~~\n\n","tags":["生活"]},{"title":"Java多线程笔记","url":"/2023/04/12/Java多线程笔记/","content":"\n# 多线程意义\n\n在同一时间需要完成多项任务时需要多线程。\n\n参考视频：[看动画，学Java多线程教程](https://www.bilibili.com/video/BV1Z54y1j7JT)\n\n# 创建线程三种方式\n\n## 继承Thread类\n\n~~~java\npackage main;\n//自定义Thread类\npublic class MyThread extends Thread {\n    @Override\n    public void run(){\n        System.out.println(\"将执行任务写到run方法里\");\n    }\n}\n~~~\n\n~~~java\npackage main;\npublic class Main{\n    //创建MyThread实例\n    MyThread mythread = new MyThread();\n    //启动线程\n    myThread.start();\n}\n~~~\n\n## 实现Runnable接口\n\nRunnable没有启动线程的能力，需要搭配thread来用。\n\n~~~java\npackage main;\n//自定义任务\npublic class Task  implements Runnable {\n    @Override\n    public void run(){\n        System.out.println(\"将执行任务写到run方法里\");\n    }\n}\n~~~\n\n~~~java\npackage main;\npublic class Main {\n    public static void main(String[] args) {\n        //创建Task实例\n        Task task = new Task();\n        //创建线程\n        Thread thread = new Thread(task);\n        //启动线程\n        thread.start();\n    }\n}\n~~~\n\n## 实现Callable接口\n\nCallable没有启动线程的能力，需要搭配thread来用。同时，Callable需要返回泛型。\n\n~~~java\npackage main;\nimport java.util.concurrent.Callable;\n//自定义任务\npublic class Result implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        return \"将要执行的任务写在call方法里面并返回执行的结果\";\n    }\n}\n~~~\n\n~~~java\npackage main;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\npublic class Main {\n    public static void main(String[] args) throws InterruptedException{\n        //创建Result示例\n        Result result = new Result();\n        //创建FutureTask实例\n        FutureTask<String> futureTask = new FutureTask<>(result);\n        //创建线程\n        Thread thread = new Thread(futureTask);\n        //启动线程\n        thread.start();\n        try {\n            //获取执行结果\n            String str = futureTask.get();\n            //输出执行结果\n            System.out.println(str);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }catch (ExecutionException e){\n            e.printStackTrace();\n        }\n    }\n}\n~~~\n\n## 总结\n\n| 创建方式 |         使用场景         |\n| :------: | :----------------------: |\n|  Thread  | 单继承（不建议在开发用） |\n| Runnable |        无返回任务        |\n| Callable |        有返回任务        |\n\n# 获取当前执行任务的线程 currentThread()\n\n~~~java\npackage main;\npublic class Main {\n    public static void main(String[] args){\n        //获取当前正在执行任务的线程\n        Thread thread = Thread.currentThread();\n        //输出当前线程\n        System.out.println(thread);\n    }\n}\n~~~\n\n输出结果：\n\n~~~java\nThread[main,5,main]\n~~~\n\nmain：线程的名称\n\n5：线程的优先级\n\nmain：线程所属的线程组名称\n\n# 获取和设置线程的名称、优先级\n\n## 获取线程名称 getName()\n\n~~~\nString str = thread.getName();\n~~~\n\n## 设置线程名称 setName(String name)\n\n~~~java\nthread.setName(\"在这里设置名称\");\n~~~\n\n## 获取线程优先级 getPriority()\n\n~~~\nint priority = thread.getPriority();\n~~~\n\n## 设置线程优先级 setPriority()\n\n~~~\nthread.setPriority();\n~~~\n\n### 常用优先级常量\n\n~~~java\n//最小优先级\npublic final static int MIN_PRIORITY = 1;\n//最大优先级\npublic final static int MAX_PRIORITY = 10;\n//默认优先级\npublic final static int NORM_PRIORITY = 5;\n~~~\n\n~~~\n//调用优先级常量（最大）\nthread.setPriority(Thread.MAX_PRIORITY);\n~~~\n\n# run()与start()区别\n\n## 位置\n\n虽然都在Thread，但是run方法重写自Runnable接口。\n\n## 类型\n\nrun是非同步方法，start是同步方法。\n\n## 作用\n\nrun存放执行代码，start启动线程，启动后执行run方法。\n\n## 是否产生线程\n\nrun不产生线程，start只产生一个线程。\n\n~~~java\npackage main;\npublic class Task implements Runnable {\n    @Override\n    public void run(){\n        //获取当前正在执行任务的线程\n        Thread thread = Thread.currentThread();\n        //获取线程名称\n        String threadName = thread.getName();\n        //打印线程的名称\n        System.out.println(threadName);\n    }\n}\n~~~\n\n~~~java\npackage main;\npublic class Main{\n    public static void main(String[] args){\n        //创建任务\n        Task task = new Task();\n        Thread thread = new Thread(task);\n        //调用run方法\n        thread.run();\n    }\n}\n~~~\n\n输出结果：\n\n~~~\nmain\n~~~\n\n## 调用次数\n\nrun可调用无限次，start只能调用一次。\n\n# 进入休眠 sleep()\n\n~~~java\n/**\n*@throws IllegalArgumentException 如果millis值为负数\n*@throws InterruptedException 如果有任何线程中断了当前线程。引发此异常时，将清除当前的中断状态。\n*/\npublic static native void sleep(long millis) throws InterruptedException\n~~~\n\n~~~java\n/**\n*@param nanos 额外指定睡眠时间的纳秒部分。范围为0-999999\n*@throws IllegalArgumentException 如果millis值为负数，或者nanos值不在范围内\n*@throws InterruptedException 如果有任何线程中断了当前线程。引发此异常时，将清除当前的中断状态。\n*/\npublic static void sleep(long millis, int nanos) throw InterruptedException\n~~~\n\n# 中断线程\n\n## 停止正在运行的线程\n\n### 中断标记 interrupt()\n\n~~~java\npackage main;\npublic class Task implements Runnable {\n    @Override\n    public void run(){\n        //无限打印语句\n        while(true){\n            System.out.println(\"正在运行\");\n        }\n    }\n}\n~~~\n\n~~~java\npackage main;\npublic class Main{\n\tpublic static void main(String[] args) throws InterruptedException{\n        Task task = new Task();\n        Thread thread = new Thread(task);\n        thread.start();\n        //使线程休眠1秒钟\n        Thread.sleep(1000);\n        //中断程序\n        thread.interrupt();\n    }\n}\n~~~\n\n输出结果：\n\n~~~\n正在运行\n正在运行\n正在运行\n...（不会停止）\n~~~\n\n原因：interrupt只是标记，中断操作要在run()方法里面操作。\n\n### 中断操作 isInterrupt()和interrupted()\n\n| 方法名称      | 类型                         | 作用                               |\n| ------------- | ---------------------------- | ---------------------------------- |\n| isInterrupted | 非静态方法                   | 判断线程是否被中断                 |\n| interrupted   | 静态方法（可通过类直接调用） | 判断线程是否被中断，并清除中断标记 |\n\nisInterrupted()：\n\n~~~java\npackage main;\npublic class Task implements Runnable {\n    @Override\n    public void run(){\n        //无限打印语句\n        while(true){\n            //获取当前正在执行的线程\n            Thread thread = Thread.currentThread();\n            //当线程被中断时\n            if(thread.isInterrupted()){\n                //结束循环\n                break;\n            }\n            System.out.println(\"正在运行\");\n        }\n    }\n}\n~~~\n\ninterrupted()：\n\n~~~java\npackage main;\npublic class Task implements Runnable {\n    @Override\n    public void run(){\n        //无限打印语句\n        while(true){\n            //当线程被中断时\n            if(Thread.interrupted()){\n                //结束循环\n                break;\n            }\n            System.out.println(\"正在运行\");\n        }\n    }\n}\n~~~\n\n一样效果，可结束线程\n\nisInterrupted()：\n\n~~~java\n...\n@Override\n    public void run(){\n    while(true){\n        Thread thread = Thread.currentThread();\n        //打印线程是否被中断\n        System.out.println(thread.isInterrupted());\n    }\n}\n~~~\n\n输出结果：\n\n~~~\nfalse\nfalse\n...\nfalse\ntrue\ntrue\n...\n~~~\n\ninterrupted()：\n\n~~~java\n...\n@Override\n    public void run(){\n    while(true){\n        //打印线程是否被中断\n        System.out.println(Thread.interrupted());\n    }\n}\n~~~\n\n输出结果：\n\n~~~\nfalse\nfalse\n...\nfalse\ntrue\nfalse\nfalse\n...\n~~~\n\n## 停止休眠中的线程\n\n~~~java\n...\n@Override\npublic void run(){\n    try{\n        //使当前线程休眠10秒钟\n        Thread.sleep(10000);\n    }catch (InterruptedException e){\n        e.printStackTrace();\n    }\n}\n~~~\n\n输出结果：\n\n~~~java\njava.lang.InterruptedException: sleep interrupted\n\tat java.base/java.lang.Thread.sleep(Native Method)\n\tat com.example.demo.Task.run(Task.java:8)\n\tat java.base/java.lang.Thread.run(Thread.java:833)\n~~~\n\n# 让别的线程得到更多执行权 yield()\n\n在run()方法中使用Thread.yield()方法可以让别的线程得到更多执行权，但不是放弃执行权。\n\n~~~java\npublic class PrintTask implements Runnable{\n    @Override\n    public void run(){\n        while (ValueTask.value==0){\n            Thread.yield();//让另一个线程得到更多执行权，减少空转\n        }\n        System.out.println(ValueTask.value);\n    }\n}\n~~~\n\n~~~java\npublic class ValueTask implements Runnable{\n    public static int value = 0;\n    @Override\n    public void run(){\n        System.out.println(6);\n        try{\n            Thread.sleep(1000);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        value = 100;\n    }\n}\n~~~\n\n# 等待线程死亡 join()\n\n在一个线程中的run()方法中调用另一个线程的join()方法时，调用线程将被阻塞，直到另一个线程执行完为止（一定要在join()之前先start()，不然直接join直接结束）\n\n~~~java\n    public final void join() throws InterruptedException {\n        join(0);\n    }\n~~~\n\n~~~java\npublic class Task implements Runnable{\n    @Override\n    public void run(){\n        JoinTask joinTask = new JoinTask();\n        Thread joinThread = new Thread(joinTask);\n        System.out.println(JoinTask.value);\n        try {\n            joinThread.start();//一定要在join()之前先start()\n            joinThread.join();\n            System.out.println(JoinTask.value);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n    }\n}\n~~~\n\n~~~java\npublic class JoinTask implements Runnable{\n    public static int value = 0;\n    @Override\n    public void run(){\n        value = 100;\n    }\n}\n~~~\n\n# 守护线程（后台线程） daemon()\n\n## 设置守护线程 setDaemon()\n\n~~~java\npublic final void setDaemon(boolean on)\n~~~\n\n\n\n~~~java\npublic class Main {\n    public static void main(String[] args){\n        PrintTask printTask = new PrintTask();\n        Thread printThread = new Thread(printTask);\n        printThread.setDaemon(true);//要在start之前设置守护线程\n        printThread.start();\n        try {\n            Thread.sleep(1000);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n    }\n}\n~~~\n\n~~~java\npublic class PrintTask implements Runnable{\n    @Override\n    public void run(){\n        while (true){\n            System.out.println(\"线程运行中\");\n        }\n    }\n}\n~~~\n\n线程在主线程结束时结束。\n\n## 判断线程是否为后台线程 isDaemon()\n\n~~~java\npublic final boolean isDaemon()\n~~~\n\n# 线程是否死亡 isAlive()\n\n~~~java\npublic final native boolean isAlive();\n~~~\n\n# *同步锁 synchronized\n\n线程获得同步锁对象后，只能该线程占用这个对象，其他线程必须等待该线程释放了该对象才能占用这个对象。解决线程安全问题。\n\n~~~\nsynchronized(object){}\n访问修饰符 synchronized 返回值类型 方法名(参数类型 参数名称){}\n访问修饰符 static synchronized 返回值类型 方法名(参数类型 参数名称){}\n~~~\n\n~~~java\npublic class Main {\n    public static void main(String[] args){\n        TicketingTask ticketingTask = new TicketingTask();//创建一个任务，多个线程执行该任务\n        Thread ticketingThread1 = new Thread(ticketingTask);\n        Thread ticketingThread2 = new Thread(ticketingTask);\n        Thread ticketingThread3 = new Thread(ticketingTask);\n        ticketingThread1.setName(\"1号\");\n        ticketingThread2.setName(\"2号\");\n        ticketingThread3.setName(\"3号\");\n        ticketingThread1.start();\n        ticketingThread2.start();\n        ticketingThread3.start();\n    }\n}\n~~~\n\n~~~java\npublic class TicketingTask implements Runnable{\n    private int ticket = 10;\n    @Override\n    public void run(){\n        while (ticket>0){\n            synchronized (this){\n                if(ticket>0){//要双重判断，因为在卖最后一票的时候另外2个线程同时锁外面等待。\n                    System.out.println(ticket+\"号票卖出，窗口为\"+Thread.currentThread().getName());\n                    ticket--;\n                }\n            }\n        }\n    }\n}\n~~~\n\n## 可同步的内容\n\n### 同步代码块\n\n~~~java\nsynchronized(对象){\n\t//需要被同步的代码\n}\n~~~\n\n### 同步方法\n\n~~~java\npublic synchronized void show (String name){\n}\n~~~\n\n### 同步类\n\n~~~java\nsynchronized(类名.class){}\n~~~\n\n\n\n## 死锁\n\n死锁指2个或2个以上的线程争夺彼此的锁，造成阻塞，程序永远处于阻塞状态。\n\n### 死锁产生的条件\n\n两个或两个以上的线程\n\n两个或两个以上的锁\n\n两个或两个以上的线程持有不同锁\n\n持有不同锁的线程争夺对方的锁\n\n### 示例\n\n~~~java\npublic class Main {\n    public static void main(String[] args){\n        LockA lockA = new LockA();\n        LockB lockB = new LockB();\n        lockA.start();\n        lockB.start();\n    }\n}\n~~~\n\n~~~java\npublic class LockA extends Thread{\n    @Override\n    public void run(){\n        printA();\n        //调用不同的锁\n    }\n    public static synchronized void printA(){\n        try{\n            Thread.sleep(1000);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        System.out.println(\"A\");\n        LockB.printB();\n        //争夺B线程的锁\n    }\n}\n~~~\n\n~~~java\npublic class LockB extends Thread {\n    @Override\n    public void run(){\n        printB();\n        //调用不同的锁\n    }\n    public static synchronized void printB(){\n        try{\n            Thread.sleep(1000);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        System.out.println(\"B\");\n        LockA.printA();\n        //争夺A线程的锁\n    }\n}\n~~~\n\n## 等待唤醒机制 wait(), notify()\n\n### wait()\n\n~~~java\n/**\n* 使当前线程等待，直到被唤醒。\n* @throws IllegalMonitorStateException 如果当前线程没有锁，则引发该异常。\n* @throws InterruptedException 如果当前线程被中断，则引发该异常。\n**/\npublic final void wait() throws InterruptedException\n~~~\n\n### notify()\n\n~~~java\n/**\n*唤醒单个线程。\n*@throws IllegalMonitorStateException 如果当前线程没有拥有锁，则引发该异常。\n*/\npublic final native void notify()\n~~~\n\n示例\n\n~~~java\npublic class LockA extends Thread{\n    @Override\n    public void run(){\n        printA();\n    }\n    public static synchronized void printA(){\n        try{\n            Thread.sleep(1000);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        System.out.println(\"A\");\n        synchronized (LockB.class){//使当前线程有对应的锁\n            LockB.class.notify();//唤醒线程\n        }\n    }\n}\n~~~\n\n~~~java\npublic class LockB extends Thread {\n    @Override\n    public void run(){\n        printB();\n    }\n    public static synchronized void printB(){\n        try{\n            Thread.sleep(1000);\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        try{\n            LockB.class.wait();//等待唤醒\n        }catch (InterruptedException e){\n            e.printStackTrace();\n        }\n        System.out.println(\"B\");\n    }\n}\n~~~\n\n### 唤醒所有线程 notifyAll() ，使用方法和notify类似\n\n### wait()和sleep()区别\n\n|                          | sleep()            | wait()                 |\n| ------------------------ | ------------------ | ---------------------- |\n| 位置                     | Thread类           | Object类               |\n| 是否需要当前线程拥有锁？ | 不需要             | 需要                   |\n| 是否支撑手动唤醒？       | 不支持             | notify()、notifyAll()  |\n| 是否支持自动唤醒？       | sleep(long millis) | wait(long timeout)     |\n| 是否支持中断？           | interrupt          | interrupt              |\n| 是否释放锁？             | 否                 | 是                     |\n| 线程状态                 | TIMED_WAITING      | WAITING、TIMED_WAITING |\n\n# ","tags":["多线程"]},{"title":"下载加速（长期更新）","url":"/2023/03/30/下载加速（长期更新）/","content":"\n​\t本博客暂时演示Windows版的各种常用下载和加速，以后可能会更新安卓版的。如果方法失效了可以在评论区留言，我会再找新的方法。\n\n# 百度网盘下载慢\n\n​\t正常下载安装百度网盘客户端，依次点击右上角的设置->传输->优化速率那一栏的去开启\n\n![image-20230330201611102](https://s1.vika.cn/space/2023/03/30/1b178e8c5ecc436fb4b8b2de164a2d62)\n\n​\t点击同意的√->开启优化速率，然后点右下角的应用就行了。\n\n![image-20230330201832151](https://s1.vika.cn/space/2023/03/30/9ca649e5e5f741a894d904558cc44602)\n\n# bt种子下载慢、磁链下载慢、直链下载慢\n\n下载开源软件[motrix](https://motrix.app)，然后直接打开使用即可。\n\n# GitHub源代码/发行文件下载慢\n\n​\t先安装并配置好上面的idm，然后复制GitHub上的源代码/发行文件的HTTPS链接，打开[Doget - Github release 下载，文件下载加速 (nocsdn.com)](https://doget.nocsdn.com/#/)并把链接粘贴解析。解析完成复制下面的磁链到motrix或者idm下载。\n\n# xbox商店下载慢\n\n打开设置（按win+i)->左侧的网络和Internet->如果和我一样用wifi的话就点WLAN->正在连接的WiFi名字属性->DNS服务器分配那一栏点编辑->改成手动->IPv4开->设置首选DNS和备用DNS（后面会给出，选择最快的那个就行了）->保存->重开wifi\n\n![image-20230330203945426](https://s1.vika.cn/space/2023/03/30/e0b7ebe2fd9f4a8ca99ed62aa9967541)\n\n```\n方案一：主DNS：4.2.2.1；辅助DNS：114.114.114.114\n方案二：主DNS：114.114.114.114；辅助DNS：114.114.115.115\n方案三：主DNS：4.2.2.1；辅助DNS：4.2.2.2\n方案四：主DNS：168.126.63.1；辅助DNS：168.126.63.2\n方案五：主DNS：123.125.81.6；辅助DNS：140.207.198.6\n方案六：主DNS：198.153.192.40；辅助DNS：198.153.194.40\n```\n\n# QQ文件下载慢\n\n​\t先把文件转发然后下载。","tags":["下载"]},{"title":"后端术语（长期更新）","url":"/2023/03/27/后端术语（长期更新）/","content":"\n# A\n\n# B\n\n并发(concurrency)：指2个或多个事件在同一个时间段内发生。在一段时间内，有多条指令在单个CPU上快速轮换、交替执行，使得在宏观上具有多个进程同步时执行的效果。\n\n![image-20230412190546582](https://s1.vika.cn/space/2023/04/12/da17c27b96514504b21224096dac0aee)\n\n并行(parallel)：指2个或以上的事件在同一时刻发生，同一时刻，有多条指令在多个CPU上同时运行。\n\n![image-20230412190251593](https://s1.vika.cn/space/2023/04/12/de2a7a7ffcbd484a81d26567546ce10f)\n\n# C\n\n程序(program)：为完成特定任务，用某种语言编写的一种指令的集合。即指一段静态的代码，静态对象。\n\n池化思想(pooling)：为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。\n\n# D\n\n# E\n\n# F\n\n反射(reflection)：是指程序在运行时可以访问、检测和修改它本身状态或者行为的一种能力。用比喻来说，反射就是在程序运行时能够“观察”并且修改自己的行为。java中，是指在运行状态中，对于任意一个类，都能够智斗这个类的所有属性和方法；对于任意一个对象，都能调用它的任意方法和属性。\n\n分时系统(time-sharing)：是计算机科学中对资源的一种共享方式，利用多道程序与多任务处理使多个用户可以同时使用一台计算机。\n\n# G\n\n关系数据库(relational database)：关系数据库是一种用于存储**相互关联的数据点**并提供数据点访问的数据库。它采用关系模型，直接、直观地在表中展示数据。在关系数据库中，表中的每一行都代表一条记录，每条记录都具有一个唯一的 ID（又被称为键），而表中的列则用于存储数据的属性 — 每条记录的每一个属性通常都有一个值。\n\n# H\n\n# I\n\n# J\n\n进程(process)：程序的一次执行过程，或是正在内存中运行的应用程序。与程序不同，进程是动态的。进程是**操作系统**调度和分配资源的最小单位（也是系统运行程序的基本单位），系统在运行时分配不同的内存空间区域。\n\n# K\n\n# L\n\n# M\n\n# N\n\n内核(kernel)：属于操作系统的一部分，是真正与硬件交互的部分，还负责分配资源。\n\n# O\n\n# P\n\n# Q\n\n# R\n\n# S\n\n时间片(timeslice)：是分时系统分配给每个正在运行的进程微观上的一段CPU时间。\n\n# T\n\n同步机制(synchronized)：Java中用于解决多线程并发访问一个资源的安全性问题（类似解决重复票与不存在票的问题）。使用同步锁。\n\n同步锁(synchronization lock)：任何线程想要执行某段被同步锁锁住的代码，都要先获得该锁。\n\n# U\n\n# V\n\n# W\n\n# X\n\n线程(thread)：进程可进一步细化为线程，是程序内部的一条执行路径。一个进程中至少有一个线程。一个进程同一时间若并行多个线程，就是支持多线程的。线程是**CPU**调度和执行的最小单位。一个进程中的多个线程共享相同的内存单元，从同一堆中分配对象，可使用相同的变量和对象。虽然高效但可能会有安全问题。单核CPU是假的多线程，是用到了并发。\n\n线程调度(thread scheduling)：指操作系统决定哪个线程将获得处理器的时间片运行，哪些线程将被暂停或者阻塞。\n\n线程池(thread pool)：一种基于池化思想管理线程的工具。线程池维护多个线程，等待监督管理者分配可并发执行的任务。本质是对任务和线程的管理。\n\n# Y\n\n# Z\n\n字段(field)：在计算机科学中，字段是指关系数据库中表的**一列**。在面向对象编程中，字段（也称为数据成员或成员变量）是封装在类或对象内部的特定数据。\n\n阻塞队列(BlockingQueue)：是一个支持两个附加操作的队列。","tags":["术语"]},{"title":"v2ray使用教程","url":"/2023/03/17/v2ray使用教程/","content":"\n本文只展示Windows版本和Android版本的演示。\n\n# Windows版\n\n1.先去GitHub下载对应的版本：[Releases · 2dust/v2rayN (github.com)](https://github.com/2dust/v2rayN/releases)，请注意看里面的说明。本文演示的版本为V6.18。\n\n2.下载好后解压文件夹，解压的位置不能选择在如C:\\Program Files这种需要管理员权限的位置，因为解压到这些位置会有打不开的bug。不知道之后的版本会不会修复。\n\n3.解压好之后打开v2rayN.exe（最好右键以管理员身份运行）。这时候你有两种选择。\n\n## 选择订阅（推荐）\n\n1.点击上面那一栏的订阅分组->订阅分组设置->添加。\n\n![v2ray使用教程1](https://s1.vika.cn/space/2023/03/19/0626a6c337a64446b0d70c911511eb8b)\n\n![v2ray使用教程2](https://s1.vika.cn/space/2023/03/19/4e23dbff40f34a5db3f54fc27310a05b)\n\n2.别名随便取一个，可选地址我找了一些订阅链接，也可以选择你自己找到的订阅地址（如在[github.com](https://github.com)搜索v2ray，然后Sort选择Recently updated），之后自己慢慢找。其他的可以暂时不用填。建议多订阅几个。\n\n```http\nhttps://raw.githubusercontent.com/ssrsub/ssr/master/V2Ray\nhttps://9527521.xyz/pubconfig/5jJlofW2hzG8krXU\n```\n\n3.添加完成后回到软件主界面，点击订阅分组->更新全部订阅（不通过代理）然后等待下方信息栏出现配置成功。\n\n![v2ray使用教程3](https://s1.vika.cn/space/2023/03/19/a0a8d80110ba45389d5052d9334d0107)\n\n4.按快捷键Ctrl+A全选服务器，然后右键，选择测试服务器真链接延迟（多选）（Ctrl+R），测试延迟。\n\n![v2ray使用教程4](https://s1.vika.cn/space/2023/03/19/1128eecfce934f63a3a4f2b00125725e)\n\n5.在每个节点的最右边都会显示延迟。如果想要快速找到低延迟节点，则点击一下 延迟 来排序。鼠标选择好节点后按Enter键勾选。\n\n![v2ray使用教程5](https://s1.vika.cn/space/2023/03/19/0b584178492b4185be14b05cb0b08288)\n\n6.在任务栏找到v2ray并右键，建议选择自动配置系统代理。然后就可以科学上网了。\n\n![v2ray使用教程6](https://s1.vika.cn/space/2023/03/19/446a587bd50f49d194708f5082c56011)\n\n7.以后的使用就只用测试节点延迟和连接就行了，如果节点延迟都是-1那就更新一下订阅。如果无效服务器太多，可以全选后右键移除所有服务器再更新订阅。\n\n## 选择自己找节点\n\n1.下面提供的节点估计很快就会无效。可以自己去[github.com](https://github.com)上搜索v2ray，然后Sort选择Recently updated。\n\n```\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p01.mcfront.xyz:31116?allowInsecure=0&peer=jp01.lovemc.xyz&sni=jp01.lovemc.xyz#%E5%89%A9%E4%BD%99%E6%B5%81%E9%87%8F%EF%BC%9A10%20GB\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p01.mcfront.xyz:31116?allowInsecure=0&peer=jp01.lovemc.xyz&sni=jp01.lovemc.xyz#%E5%A5%97%E9%A4%90%E5%88%B0%E6%9C%9F%EF%BC%9A%E9%95%BF%E6%9C%9F%E6%9C%89%E6%95%88\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p01.mcfront.xyz:31116?allowInsecure=0&peer=jp01.lovemc.xyz&sni=jp01.lovemc.xyz#%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E8%AF%B7%E6%9D%A5%E5%AE%98%E7%BD%91%E6%9B%B4%E6%96%B0%E8%AE%A2%E9%98%85\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p01.mcfront.xyz:31116?allowInsecure=0&peer=jp01.lovemc.xyz&sni=jp01.lovemc.xyz#%E5%AE%98%E7%BD%91%E5%9C%B0%E5%9D%80%EF%BC%9A%20mikasacloud.site\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p01.mcfront.xyz:31116?allowInsecure=0&peer=jp01.lovemc.xyz&sni=jp01.lovemc.xyz#%E6%B0%B8%E4%B9%85%E5%9F%9F%E5%90%8D%E5%8F%91%E5%B8%83%E9%A1%B5%EF%BC%9Amcrelease.xyz\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p01.mcfront.xyz:31116?allowInsecure=0&peer=jp01.lovemc.xyz&sni=jp01.lovemc.xyz#%E6%97%A5%E6%9C%AC%2001%20%7C%201x%20JP\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p02.mcfront.xyz:31106?allowInsecure=1&peer=jp02.lovemc.xyz&sni=jp02.lovemc.xyz#%E6%97%A5%E6%9C%AC%2002%20%20%7C%201x%20JP\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6w7j3p03.mcfront.xyz:31111?allowInsecure=0&peer=jp03.lovemc.xyz&sni=jp03.lovemc.xyz#%E6%97%A5%E6%9C%AC%2003%20%20%7C%201x%20JP\nvmess://eyJ2IjoiMiIsInBzIjoiXHU2NWU1XHU2NzJjIDA0ICB8IDF4IEpQIiwiYWRkIjoiNnc3ajNwMDQubWNmcm9udC54eXoiLCJwb3J0IjoiMzExMTYiLCJpZCI6IjliYjQyYzZlLTI5NzMtNDI2Ni1hZjRmLWFkM2JlNGVmNGQ5OCIsImFpZCI6IjAiLCJuZXQiOiJ0Y3AiLCJ0eXBlIjoibm9uZSIsImhvc3QiOiIiLCJwYXRoIjoiIiwidGxzIjoidGxzIiwic25pIjoianAwNC5sb3ZlbWMueHl6In0=\nvmess://eyJ2IjoiMiIsInBzIjoiXHU2NWU1XHU2NzJjIDA1ICB8IDF4IEpQIiwiYWRkIjoiNnc3ajNwMDUubWNmcm9udC54eXoiLCJwb3J0IjoiMzExMDYiLCJpZCI6IjliYjQyYzZlLTI5NzMtNDI2Ni1hZjRmLWFkM2JlNGVmNGQ5OCIsImFpZCI6IjAiLCJuZXQiOiJ0Y3AiLCJ0eXBlIjoibm9uZSIsImhvc3QiOiIiLCJwYXRoIjoiIiwidGxzIjoidGxzIiwic25pIjoianAwNS5sb3ZlbWMueHl6In0=\nvmess://eyJ2IjoiMiIsInBzIjoiXHU2NWU1XHU2NzJjIDA2ICB8IDF4IEpQIiwiYWRkIjoiNnc3ajNwMDYubWNmcm9udC54eXoiLCJwb3J0IjoiMzExMTEiLCJpZCI6IjliYjQyYzZlLTI5NzMtNDI2Ni1hZjRmLWFkM2JlNGVmNGQ5OCIsImFpZCI6IjAiLCJuZXQiOiJ0Y3AiLCJ0eXBlIjoibm9uZSIsImhvc3QiOiIiLCJwYXRoIjoiIiwidGxzIjoidGxzIiwic25pIjoianAwNi5sb3ZlbWMueHl6In0=\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@5m4h0k01.mcfront.xyz:31601?allowInsecure=0&peer=hk01.lovemc.xyz&sni=hk01.lovemc.xyz#%E9%A6%99%E6%B8%AF%2001%20%7C%201x%20HK\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@5m4h0k02.mcfront.xyz:31606?allowInsecure=0&peer=hk02.lovemc.xyz&sni=hk02.lovemc.xyz#%E9%A6%99%E6%B8%AF%2002%20%7C%201x%20HK\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@5m4h0k03.mcfront.xyz:31611?allowInsecure=0&peer=hk03.lovemc.xyz&sni=hk03.lovemc.xyz#%E9%A6%99%E6%B8%AF%2003%20%7C%201x%20HK\nvmess://eyJ2IjoiMiIsInBzIjoiXHU5OTk5XHU2ZTJmIDA0IHwgMXggSEsiLCJhZGQiOiI1bTRoMGswNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTYwMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJoazA0LmxvdmVtYy54eXoifQ==\nvmess://eyJ2IjoiMiIsInBzIjoiXHU5OTk5XHU2ZTJmIDA1IHwgMXggSEsiLCJhZGQiOiI1bTRoMGswNS5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTYwNiIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJoazA1LmxvdmVtYy54eXoifQ==\nvmess://eyJ2IjoiMiIsInBzIjoiXHU5OTk5XHU2ZTJmIDA2IHwgMXggSEsiLCJhZGQiOiI1bTRoMGswNi5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTYxMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJoazA2LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@2d1t5w01.mcfront.xyz:31301?allowInsecure=0&peer=tw01.lovemc.xyz&sni=tw01.lovemc.xyz#%E5%8F%B0%E6%B9%BE%2001%20%20%7C%201x%20TWN\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@2d1t5w02.mcfront.xyz:31306?allowInsecure=0&peer=tw02.lovemc.xyz&sni=tw02.lovemc.xyz#%E5%8F%B0%E6%B9%BE%2002%20%20%7C%201x%20TWN\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@2d1t5w03.mcfront.xyz:31311?allowInsecure=0&peer=tw03.lovemc.xyz&sni=tw03.lovemc.xyz#%E5%8F%B0%E6%B9%BE%2003%20%20%7C%201x%20TWN\nvmess://eyJ2IjoiMiIsInBzIjoiXHU1M2YwXHU2ZTdlIDA0ICB8IDF4IFRXTiIsImFkZCI6IjJkMXQ1dzA0Lm1jZnJvbnQueHl6IiwicG9ydCI6IjMxMzAxIiwiaWQiOiI5YmI0MmM2ZS0yOTczLTQyNjYtYWY0Zi1hZDNiZTRlZjRkOTgiLCJhaWQiOiIwIiwibmV0IjoidGNwIiwidHlwZSI6Im5vbmUiLCJob3N0IjoiIiwicGF0aCI6IiIsInRscyI6InRscyIsInNuaSI6InR3MDQubG92ZW1jLnh5eiJ9\nvmess://eyJ2IjoiMiIsInBzIjoiXHU1M2YwXHU2ZTdlIDA1ICB8IDF4IFRXTiIsImFkZCI6IjJkMXQ1dzA1Lm1jZnJvbnQueHl6IiwicG9ydCI6IjMxMzA2IiwiaWQiOiI5YmI0MmM2ZS0yOTczLTQyNjYtYWY0Zi1hZDNiZTRlZjRkOTgiLCJhaWQiOiIwIiwibmV0IjoidGNwIiwidHlwZSI6Im5vbmUiLCJob3N0IjoiIiwicGF0aCI6IiIsInRscyI6InRscyIsInNuaSI6InR3MDUubG92ZW1jLnh5eiJ9\nvmess://eyJ2IjoiMiIsInBzIjoiXHU1M2YwXHU2ZTdlIDA2ICB8IDF4IFRXTiIsImFkZCI6IjJkMXQ1dzA2Lm1jZnJvbnQueHl6IiwicG9ydCI6IjMxMzExIiwiaWQiOiI5YmI0MmM2ZS0yOTczLTQyNjYtYWY0Zi1hZDNiZTRlZjRkOTgiLCJhaWQiOiIwIiwibmV0IjoidGNwIiwidHlwZSI6Im5vbmUiLCJob3N0IjoiIiwicGF0aCI6IiIsInRscyI6InRscyIsInNuaSI6InR3MDYubG92ZW1jLnh5eiJ9\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@1c7s2g01.mcfront.xyz:31201?allowInsecure=0&peer=sg01.lovemc.xyz&sni=sg01.lovemc.xyz#%E6%96%B0%E5%8A%A0%E5%9D%A1%2001%20%20%7C%201x%20SG\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@1c7s2g02.mcfront.xyz:31206?allowInsecure=0&peer=sg02.lovemc.xyz&sni=sg02.lovemc.xyz#%E6%96%B0%E5%8A%A0%E5%9D%A1%2002%20%7C%201x%20SG\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@1c7s2g03.mcfront.xyz:31211?allowInsecure=0&peer=sg03.lovemc.xyz&sni=sg03.lovemc.xyz#%E6%96%B0%E5%8A%A0%E5%9D%A1%2003%20%7C%201x%20SG\nvmess://eyJ2IjoiMiIsInBzIjoiXHU2NWIwXHU1MmEwXHU1NzYxIDA0IHwgMXggU0ciLCJhZGQiOiIxYzdzMmcwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTIwMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJzZzA0LmxvdmVtYy54eXoifQ==\nvmess://eyJ2IjoiMiIsInBzIjoiXHU2NWIwXHU1MmEwXHU1NzYxIDA1IHwgMXggU0ciLCJhZGQiOiIxYzdzMmcwNS5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTIwNiIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJzZzA1LmxvdmVtYy54eXoifQ==\nvmess://eyJ2IjoiMiIsInBzIjoiXHU2NWIwXHU1MmEwXHU1NzYxIDA2IHwgMXggU0ciLCJhZGQiOiIxYzdzMmcwNi5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTIxMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJzZzA2LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@4a2u0a01.mcfront.xyz:31501?allowInsecure=0&peer=us01.lovemc.xyz&sni=us01.lovemc.xyz#%E7%BE%8E%E5%9B%BD%2001%20%7C%201x%20US\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@4a2u0a02.mcfront.xyz:31506?allowInsecure=0&peer=us02.lovemc.xyz&sni=us02.lovemc.xyz#%E7%BE%8E%E5%9B%BD%2002%20%7C%201x%20US\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@4a2u0a03.mcfront.xyz:31511?allowInsecure=0&peer=us03.lovemc.xyz&sni=us03.lovemc.xyz#%E7%BE%8E%E5%9B%BD%2003%20%7C%201x%20US\nvmess://eyJ2IjoiMiIsInBzIjoiXHU3ZjhlXHU1NmZkIDA0IHwgMXggVVMiLCJhZGQiOiI0YTJ1MGEwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTUwMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJ1czA0LmxvdmVtYy54eXoifQ==\nvmess://eyJ2IjoiMiIsInBzIjoiXHU3ZjhlXHU1NmZkIDA1IHwgMXggVVMiLCJhZGQiOiI0YTJ1MGEwNS5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTUwNiIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJ1czA1LmxvdmVtYy54eXoifQ==\nvmess://eyJ2IjoiMiIsInBzIjoiXHU3ZjhlXHU1NmZkIDA2IHwgMXggVVMiLCJhZGQiOiI0YTJ1MGEwNi5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTUxMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJ1czA2LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@8l2k1r01.mcfront.xyz:31401?allowInsecure=0&peer=kr01.lovemc.xyz&sni=kr01.lovemc.xyz#%E9%9F%A9%E5%9B%BD%2001%20%7C%201x%20KR\nvmess://eyJ2IjoiMiIsInBzIjoiXHU5N2U5XHU1NmZkIDAyIHwgMXggS1IiLCJhZGQiOiI4bDJrMXIwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTQwMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJrcjA0LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@1a4p0h01.mcfront.xyz:31801?allowInsecure=0&peer=ph01.lovemc.xyz&sni=ph01.lovemc.xyz#%E8%8F%B2%E5%BE%8B%E5%AE%BE%2001%20%7C%201x%20PH\nvmess://eyJ2IjoiMiIsInBzIjoiXHU4M2YyXHU1ZjhiXHU1YmJlIDA0IHwgMXggUEgiLCJhZGQiOiIxYTRwMGgwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTgwMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJwaDA0LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@4t1r5u01.mcfront.xyz:31851?allowInsecure=0&peer=ru01.lovemc.xyz&sni=ru01.lovemc.xyz#%E4%BF%84%E7%BD%97%E6%96%AF%2001%20%7C%201x%20RU\nvmess://eyJ2IjoiMiIsInBzIjoiXHU0ZmM0XHU3ZjU3XHU2NWFmIDA0IHwgMXggUlUiLCJhZGQiOiI0dDFyNXUwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTg1MSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJydTA0LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@6q3i1n01.mcfront.xyz:31831?allowInsecure=0&peer=in01.lovemc.xyz&sni=in01.lovemc.xyz#%E5%8D%B0%E5%BA%A6%2001%20%7C%201x%20IN\nvmess://eyJ2IjoiMiIsInBzIjoiXHU1MzcwXHU1ZWE2IDA0IHwgMXggSU4iLCJhZGQiOiI2cTNpMW4wNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTgzMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJpbjA0LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@4o5a3u01.mcfront.xyz:31821?allowInsecure=0&peer=au01.lovemc.xyz&sni=au01.lovemc.xyz#%E6%BE%B3%E5%A4%A7%E5%88%A9%E4%BA%9A%2001%20%7C%201x%20AU\nvmess://eyJ2IjoiMiIsInBzIjoiXHU2ZmIzXHU1OTI3XHU1MjI5XHU0ZTlhIDA0IHwgMXggQVUiLCJhZGQiOiI0bzVhM3UwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTgyMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJhdTA0LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@3a4u0k01.mcfront.xyz:31811?allowInsecure=0&peer=uk01.lovemc.xyz&sni=uk01.lovemc.xyz#%E8%8B%B1%E5%9B%BD%2001%20%7C%201x%20UK\nvmess://eyJ2IjoiMiIsInBzIjoiXHU4MmYxXHU1NmZkIDA0IHwgMXggVUsiLCJhZGQiOiIzYTR1MGswNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTgxMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJ1azA0LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@9t1d5e01.mcfront.xyz:31841?allowInsecure=0&peer=de01.lovemc.xyz&sni=de01.lovemc.xyz#%E5%BE%B7%E5%9B%BD%2001%20%7C%201x%20DE\nvmess://eyJ2IjoiMiIsInBzIjoiXHU1ZmI3XHU1NmZkIDA0IHwgMXggQVUiLCJhZGQiOiI5dDFkNWUwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTg0MSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJkZTA0LmxvdmVtYy54eXoifQ==\ntrojan://9bb42c6e-2973-4266-af4f-ad3be4ef4d98@3d1c4a01.mcfront.xyz:31701?allowInsecure=0&peer=ca01.lovemc.xyz&sni=ca01.lovemc.xyz#%E5%8A%A0%E6%8B%BF%E5%A4%A7%2001%20%7C%201x%20CA\nvmess://eyJ2IjoiMiIsInBzIjoiXHU1MmEwXHU2MmZmXHU1OTI3IDAyIHwgMXggQ0EiLCJhZGQiOiIzZDFjNGEwNC5tY2Zyb250Lnh5eiIsInBvcnQiOiIzMTcwMSIsImlkIjoiOWJiNDJjNmUtMjk3My00MjY2LWFmNGYtYWQzYmU0ZWY0ZDk4IiwiYWlkIjoiMCIsIm5ldCI6InRjcCIsInR5cGUiOiJub25lIiwiaG9zdCI6IiIsInBhdGgiOiIiLCJ0bHMiOiJ0bHMiLCJzbmkiOiJjYTA0LmxvdmVtYy54eXoifQ==\n```\n\n2.一大串这种东西直接复制后，点击服务器->从剪贴板导入批量URL。之后的方法步骤和上面的`选择订阅（推荐）`中4-6是一样的。\n\n![image-20230319164934380](https://s1.vika.cn/space/2023/03/19/111f258650a041d78b47401b6de98c17)\n\n如果服务器都无效了，那只能自己再去找URL了。\n\n# Android版\n\n先去GitHub下载[v2rayNG](https://github.com/2dust/v2rayNG/releases)，最好选择带有绿色Latest版本（本文章演示的是1.7.38版本），下载v2rayNG_1.7.38.apk。下载安装好后，打开软件。\n\n![image-20230319170005116](https://s1.vika.cn/space/2023/03/19/bf9dcfd784ca4878b2a00cfa812f6f3b)\n\n## 选择订阅（推荐）\n\n1.点左上角->订阅分组测试\n\n![image-20230319170215164](https://s1.vika.cn/space/2023/03/19/ea451fd656b6488da7e5c76c4b815ac1)\n\n2.点击左上角的+号，备注随便写，可选地址填订阅链接。我找了一些订阅链接，也可以选择你自己找到的订阅地址（如在[github.com](https://github.com)搜索v2ray，然后Sort选择Recently updated），之后自己慢慢找。其他的可以暂时不用填。建议多订阅几个。\n\n```http\nhttps://raw.githubusercontent.com/ssrsub/ssr/master/V2Ray\nhttps://9527521.xyz/pubconfig/5jJlofW2hzG8krXU\n```\n\n![image-20230319170559096](https://s1.vika.cn/space/2023/03/19/84ba87fde72d4c6b93d55bfc90e410ea)\n\n3.填好后点右上角√，然后选择订阅链接（左边有绿色竖线即为选中）\n\n![image-20230319170740397](https://s1.vika.cn/space/2023/03/19/fdc1e61c2cec473ea73097a4c41ab058)\n\n4.回到软件主界面，点右上角三个点->更新订阅。更新完后点右上角三个点->测试全部配置真连接。测试完后点右上角三个点->按测试结果排序，选择延迟小的就行了。\n\n![image-20230319171121936](https://s1.vika.cn/space/2023/03/19/a225684cd36d478c975d21619d78c516)\n\n## 选择自己找节点\n\n1.节点选择和Windows版的`选择自己找节点`的1一样，将URL复制。\n\n2.点右上角的+号->从剪贴板导入。之后的方法和Android版的`选择订阅（推荐）`的4一样，不过不用更新订阅。\n\n![image-20230319172457795](https://s1.vika.cn/space/2023/03/19/d332dd3f8fbb4e939ca75e8ff4b97434)\n\n","tags":["v2ray"]},{"title":"博客搭建","url":"/2023/03/13/博客搭建/","content":"\n​\t该文章基于[aircloud/hexo-theme-aircloud: A concise hexo theme (github.com)](https://github.com/aircloud/hexo-theme-aircloud)的hexo博客主题搭建，里面虽然已经有教程，但是当我这个小白照着做的时候仍然遇到一些问题。所以现在写一篇文章来聊聊我遇到的一些问题吧。\n\n# 中文问题\n\n​\t默认是英文页面。需要改为中文。\n\n![博客搭建1](https://s1.vika.cn/space/2023/03/19/477652458b5c4af0b21f42037a5458b3)\n\n​\t找到_config.yml，将language: en一栏改为language: zh\n\n![博客搭建2](https://s1.vika.cn/space/2023/03/19/e781b6ab1669442d832039c57c78104a)\n\n\n​\t部署hexo s查看情况\n\n![博客搭建3](https://s1.vika.cn/space/2023/03/19/bd46642db0514b07b8969f4e5cd65b9d)\n\n\n# \t头像问题\n\n​\t跟着做之后，我遇到了头像无法正确解析的问题。\n\n![博客搭建4](https://s1.vika.cn/space/2023/03/19/7d7d75589d8a4f96a9653ca88e1f0896)\n\n\n​\t这可能是原博客的设置问题，通过以下方法即可解决。\n\n​\t1.打开\\themes\\hexo-theme-aircloud\\layout\\\\_partial\\nav.ejs，找到\n\n```ejs\n<img src=\"<%= config['root'] %><%= config['sidebar-avatar'] %>\" />\n```\n\n![博客搭建5](https://s1.vika.cn/space/2023/03/19/c9c62f55d5684904ae5a21bdfda62fe8)\n\n\n​\t将这一行改为\n\n```ejs\n<img src=\"<%=theme.avatar%>\" class=\"js-avatar show\" />\n```\n\n![博客搭建6](https://s1.vika.cn/space/2023/03/19/fd563d2074d3406ab832e90153b5e482)\n\n\n​\t2.将自己的头像放在\\themes\\hexo-theme-aircloud\\source\\img\\下\n\n![博客搭建7](https://s1.vika.cn/space/2023/03/19/f804f275660e4fceaded1aa88027decc)\n\n\n​\t3.打开\\themes\\hexo-theme-aircloud\\_config.yml，在后面添加下面代码（将avatar.jpg改为自己的图像文件名，如果用图床方法则改为url，具体方法参考后面的部署到图床上）\n\n```yaml\navatar: /img/avatar.jpg\n```\n\n![博客搭建8](https://s1.vika.cn/space/2023/03/19/7ca3b453aef4408ab95f25a0db8754bc)\n\n\n​\t4.部署hexo s查看情况\n\n![博客搭建9](https://s1.vika.cn/space/2023/03/19/3a4c6d72b575458b853f4405913a23f4)\n\n\n# 博客文章加载问题\n\n​\t当我点开博客文章的时候，显示\n\n![博客搭建10](https://s1.vika.cn/space/2023/03/19/0ca8c43ffa434308bc4148c6de8cced8)\n\n\n​\t这是因为_config.yml默认设置问题，将里面的url改改就行了。如果本地测试改成http://localhost:4000\n\n![博客搭建11](https://s1.vika.cn/space/2023/03/19/3f6de59f96f14130bd6786618966208e)\n\n​\t之后就可以正常打开文章了。\n\n# 图片问题\n\n## 图片插入两种方法\n\n### 直接放到本地\n\n​\t优点：直接\n\n​\t缺点：GitHub加载图片慢，且图片保存在本地占空间，每次插入图片都要自己输入路径，还不能在本地Typora加载图片。本主题还会将小图片拉大。\n\n​\t图片直接放到本地博客\\source\\img\\下，然后在Typora下想要插入图片的位置加上\n\n```markdown\n![](/img/xxx.jpg)\n```\n\n### 部署到图床上（推荐）\n\n​\t优点：选择国内服务器的话图片加载快，省本地空间，Typora与PicGo搭配效率高。\n\n​\t缺点：第一次部署相对麻烦，不够直接，图片不保存在本地可能会被删库跑路（也可以自己备份就是了）。\n\n​\t先介绍几个概念。\n\n#### 图床\n\n​\t图床一般是指储存图片的服务器。选择国内的图床加载快。下面给出一些免费的图床网站，本博客只演示目前在我这里最快的图床——vika。\n\n​\t维格表vika：https://vika.cn/\n\n​\tImgTP：https://www.imgtp.com/\n\n​\tbilibilli（用这个怕被叔叔封号，且存在跨域问题）：https://www.bilibili.com/\n\n#### PicGo\n\n​\tPicGo是一个用于快速上传图片并获取图片 URL 链接的工具，关键是他可以与Typora配套一起使用，在粘贴图片的同时上传图片，十分方便！\n\n​\t[Releases · Molunerfinn/PicGo (github.com)](https://github.com/Molunerfinn/PicGo/releases)\n\n​\t建议优先选择带有绿色Latest版本，本文演示的是2.3.1版本，本人是Windows64位系统，我选择下载[PicGo-Setup-2.3.1-x64.exe](https://github.com/Molunerfinn/PicGo/releases/download/v2.3.1/PicGo-Setup-2.3.1-x64.exe)版本，并安装。\n\n![image-20230319123114541](https://s1.vika.cn/space/2023/03/19/1b51fd1f239f4e3693c4ccd4448e6665)\n\n​\t安装后打开可能会提示要更新，建议先不要更新。然后点开插件设置，搜索并安装vikadata插件。\n\n![image-20230319124309658](https://s1.vika.cn/space/2023/03/19/597fb7d068cb4d1f912075f4f7ee7441)\n\n​\t安装好后重启一下软件，点开PicGo设置，滑到最下面把请选择显示的图床都取消勾选，留下vika维格表（如果你用其他的图床就不要取消那个勾选）\n\n![image-20230319124426477](https://s1.vika.cn/space/2023/03/19/46165414339d4269b9786b6eb410aa74)\n\n​\t点图床设置->vika维格表\n\n![image-20230319124648183](https://s1.vika.cn/space/2023/03/19/41410fcfc8914ef795df9098d03859e7)\n\n\n\n​\t之后在vika注册账号，注册好登录后可以填我邀请码05665721，能拿1000 V币，3000 V币可以找客服扩容。点左下角头像->邀请好友注册领取1000 V币里面填写即可。\n\n![image-20230319140715681](https://s1.vika.cn/space/2023/03/19/0d73d007e1bf4226978d916bde01c5b5)\n\n​\t一个空间有1G的容量，每个人大概可以创建10个空间，一个图片也才几百KB，所以这些完全够用了。\n\n​\t接下来创建维格表点+号->新建空白维格表。\n\n![image-20230319141129630](https://s1.vika.cn/space/2023/03/19/c5ff5c1293494d45be0817a44e4facdf)\n\n​\t可重命名为`图床`\n\n![image-20230319143131038](https://s1.vika.cn/space/2023/03/19/9c96a3142a464677b9aa7f4cc73354a4)\n\n#### 获取API Token\n\n​\t随后点击左下角头像->个人设置，绑定自己的邮箱后，获取`API Token`\n\n![image-20230319160531198](https://s1.vika.cn/space/2023/03/19/60f54a3925e841c293e027b122a7c252)\n\n![image-20230319141859374](https://s1.vika.cn/space/2023/03/19/a2d2cb6639814337966aed7e51132e95)\n\n![image-20230319142109256](https://s1.vika.cn/space/2023/03/19/b8d29fee0e3a4659a6577beb4b7c1f78)\n\n#### 获取维格表ID\n\n![image-20230319142639209](https://s1.vika.cn/space/2023/03/19/d39fcbea64e8498392f8d2a55815bf81)\n\n![image-20230319143541221](https://s1.vika.cn/space/2023/03/19/814dc100ab3b4f2db217fecda7c6d000)\n\n​\t另外两栏可以选默认。点确定后可以试试上传。可以自己调链接格式。\n\n![image-20230319143541221](https://s1.vika.cn/space/2023/03/19/9ce04d4222e74270bc9098ce0d19d9b6)\n\n上传成功后可以点相册->复制到markdown或者浏览器查看情况。\n\n![image-20230319143541221](https://s1.vika.cn/space/2023/03/19/169c0a0114fe41c4b8536885f1215742)\n\n#### 设置Typroa\n\n​\t点文件->偏好设置\n\n![image-20230319143541221](https://s1.vika.cn/space/2023/03/19/14ddaa3c50a74974ab93b90114cfdf79)\n\n​\t点开后按照图片那样设置。\n\n![image-20230319150646293](https://s1.vika.cn/space/2023/03/19/29103acb094144d695b80a5b576f5432)\n\n![image-20230319150246053](https://s1.vika.cn/space/2023/03/19/a3bd8fa3a37d4d2f97793af966210c77)\n\n设置好后你可以直接复制粘贴到markdown并自动上传图片了，十分方便。\n\n### 当使用本地图片时\n\n如果用以下插入图片的方法\n\n```markdown\n![](本地路径)\n```\n\n​\t设置的图片大小可能会小图片拉大太糊，或者长图片显示太小，于是建议使用嵌入HTML代码的方法来自定义大小直至到满意的尺寸。\n\n​\t1.先在\\source\\img\\下放自己想要的图片，如test.jpg\n\n<div  align=\"center\">\n\t<img src=\"/img/博客搭建/博客搭建12.jpg\" />\n</div>\n\n\n​\t可以先在外面包围div来居中，如：\n\n```markdown\n<div align=\"center\">    \n\t<img src=\"xxx\" />\n</div>\n```\n\n​\t这虽然在Typora上是认不出来，但是在本地测试部署上的网页是正常的。\n\n\n\n​\t一般比较长的图片或者正常的图片也不用再添加格式样式来改，但是对于宽的图片最好还是要缩放。以下是反例。\n\n<div align=\"center\">   \n\t<img src=\"/img/博客搭建/博客搭建13.jpg\" />\n</div>\n​\t下面是加上缩放，缩放长高都设为100%。具体多少视情况而定。\n\n```markdown\n<div align=\"center\">    \n\t<img src=\"xxx\" width=\"100%\" height=\"100%\"/>\n</div>\n```\n\n<div align=\"center\">   \n\t<img src=\"/img/博客搭建/博客搭建13.jpg\" width=\"100%\" height=\"100%\"/>\n</div>\n\n# 网页标题问题\n\n​\t搭建后点开文章，发现标题有个undefined\n\n![image-20230327152753641](https://s1.vika.cn/space/2023/03/27/55295d831c90413ab6a9c72ec31d9041)\n\n​\t打开`\\_config.yml`，加上\n\n```\nSEOTitle: 替换undefined的内容\n```\n\n# 网页上方座右铭\n\n![image-20230327163809685](https://s1.vika.cn/space/2023/03/27/e71e0153cffa4489b108f1c991ca5889)\n\n​\t打开`\\_config.yml`，加上\n\n```\nsubtitle: \"你的座右铭\"\n```\n\n# 2023.5.15更新用维格作为图床403Forbidden问题\n\n前几天上博客看了下，图片都是403Forbidden，估计是维格那边的政策变了。于是找了解决方法。 \n\n打开`\\themes\\hexo-theme-aircloud\\layout\\_partial\\head.ejs`，在几行meta之间加上 \n\n```html\n  <meta name=\"referrer\" content=\"no-referrer\" />   \n```\n\n![image-20230515160307762](https://s1.vika.cn/space/2023/05/15/f63f00fb35204eda9765d2646c46e287)\n\n然后再部署就正常了\n\n# 2023.12.16更新博客转移到自己服务器上\n\n参考文章[将 Hexo 搭建的博客站点从 GitHub Pages 迁移到腾讯云 VPS - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/269456060)\n\n证书申请使用了let's encrypt的自动更新证书certbot功能https://certbot.eff.org","tags":["搭建"]}]